# 4부 컴포넌트 원칙
- SOLID 원칙이 벽과 방에 벽돌을 배치하는 방법을 알려준다면, 컴포넌트 원칙은 빌딩에 방을 배치하는 방법을 설명해 준다.


# 12장) 컴포넌트
- 서론
  - 시스템의 구성 요소로 배포할 수 있는 가장 작은 단위다.
    - 자바의 jar, 루비 gem, 닷넷 dll 
  - 여러 컴포넌트를 서로 링크하여 실행 가능한 단일 파일로 생성할 수 있다.
    - 여러 컴포넌트를 서로 묶어서 .war 파일과 같은 단일 아카이브로도 생성 가능
    - 컴포넌트 각각을 .jar, .dll 같이 동적으로 로드할 수 있는 플러그인이나 .exe 파일로 만들어 독립적으로 배포 가능
  - 잘 설계된 컴포넌트라면 반드시 독립적으로 배포 가능한/독립적으로 개발 가능한 능력을 갖춰야 한다.
  
- 컴포넌트의 간략한 역사
  - 소프트웨어 개발 초창기에는 메모리에서의 프로그램 위치와 레이아웃을 프로그래머가 직접 제어
    - 프로그램의 위치가 한번 결정되면, 재배치 불가
    - 라이브러리리 함수의 소스 코드를 애플리케이션 코드에 직접 포함시켜 단일로 컴파일 (라이브러리는 소스 코드 형태로 유지)
    - 메모리가 너무 작아서 소스 코드를 여러차례 읽어야만 했다.
  - 컴파일 시간을 단축시키기 위해 함수 라이브러리의 소스 코드를 애플리케이션 코드로부터 분리
    - 함수 라이브러리를 개별적으로 컴파일 하고 특정 위치에 로드했다.
    - 프로그램과 라이브러리가 사용하는 메모리가 늘어날 수록 단편화 지속됨 (그림 12.2)

- 재배치성
  - 지능적인 로더를 사용해서 메모리에 재배치할 수 있는 형태의 바이너리를 생성하도록 컴파일러를 수정
  - 컴파일러는 재배치 가능한 바이너리 안의 함수 이름을 메타데이터 형태로 생성
    - 라이브러리 함수를 호출한다면 컴파일러는 라이브러리 함수 이름을 외부 참조로 생성
    - 라이브러리 함수를 정의하는 프로그램이라면 컴파일러는 해당 이름을 외부 정의로 생성
      - 링킹 로더의 탄생

- 링커
  - 링킹 로더의 등장으로 프로그래머는 프로그램을 개별적으로 컴파일하고 로드할 수 있는 단위로 분할할 수 있었다.
  - 프로그램이 훨씬 커지게 되자 결국 링킹 로더 방식의 처리도 너무 느렸다.
  - 로드와 링크가 두 단계로 분리
    - 프로그래머가 느린 부분, 즉 링크 과정을 담당했는데, 링커라는 별도의 애플리케이션으로 이 작업을 처리
      - 링커는 링크가 완료된 재배치 코드를 만들어 줌 (로딩 과정이 아주 빨라짐)
  - 1980년대 소스 모듈은 .c 파일에서 .o 파일로 컴파일된 후, 링커로 전달되어 빠르게 로드될 수 있는 형태의 실행 파일로 만들어짐
    - 각 모듈의 컴파일 과정은 빨랐지만, 전체 모듈을 컴파일하는 일은 꽤 시간이 걸렸다.
  - 1980년 후반 무어의 법칙이 승리 ( 컴퓨터 속도, 메모리, 접적도가 매 18개월 마다 두배로 증가한다는 주장 )
    - 디스크는 작아지기 시작했고, 엄청 빨라짐.
    - 컴퓨터 메모리는 저렴해져서 디스크의 데이터를 모두 램에 캐싱
  - 1990년 후반에는 프로그램 성장 속도보다 링크 시간이 줄어드는 속도가 더 빨라졌다.
  - 이렇게 액티브 X와 공유 라이브러리 시대가 열렸고 .jar 파일도 등장했다.
    - 컴퓨터가 빨라져서 다시 로드와 링크를 동시에 할 수 있게 되었다.
  - **이렇게 컴포넌트 플러그인 아키텍처** 가 탄생했다.
  
- 결론
  - 런타임 플러그인 형태로 결합할 수 있는 동적 링크 파일이 소프트웨어 컴포넌트에 해당한다.


# 13장) 컴포넌트 응집도
- 


# 14장) 컴포넌트 결합



# 참고
- https://soohyeon317.tistory.com/entry/%EB%AA%A8%EB%85%B8%EB%A6%AC%ED%8B%B1Monolithic-vs-%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4Microservices
- https://thefif19wlsvy.tistory.com/24
