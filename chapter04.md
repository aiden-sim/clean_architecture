# 4부 컴포넌트 원칙
- SOLID 원칙이 벽과 방에 벽돌을 배치하는 방법을 알려준다면, 컴포넌트 원칙은 빌딩에 방을 배치하는 방법을 설명해 준다.


# 12장) 컴포넌트
- 서론
  - 시스템의 구성 요소로 배포할 수 있는 가장 작은 단위다.
    - 자바의 jar, 루비 gem, 닷넷 dll 
  - 여러 컴포넌트를 서로 링크하여 실행 가능한 단일 파일로 생성할 수 있다.
    - 여러 컴포넌트를 서로 묶어서 .war 파일과 같은 단일 아카이브로도 생성 가능
    - 컴포넌트 각각을 .jar, .dll 같이 동적으로 로드할 수 있는 플러그인이나 .exe 파일로 만들어 독립적으로 배포 가능
  - 잘 설계된 컴포넌트라면 반드시 독립적으로 배포 가능한/독립적으로 개발 가능한 능력을 갖춰야 한다.
  
- 컴포넌트의 간략한 역사
  - 소프트웨어 개발 초창기에는 메모리에서의 프로그램 위치와 레이아웃을 프로그래머가 직접 제어
    - 프로그램의 위치가 한번 결정되면, 재배치 불가
    - 라이브러리리 함수의 소스 코드를 애플리케이션 코드에 직접 포함시켜 단일로 컴파일 (라이브러리는 소스 코드 형태로 유지)
    - 메모리가 너무 작아서 소스 코드를 여러차례 읽어야만 했다.
  - 컴파일 시간을 단축시키기 위해 함수 라이브러리의 소스 코드를 애플리케이션 코드로부터 분리
    - 함수 라이브러리를 개별적으로 컴파일 하고 특정 위치에 로드했다.
    - 프로그램과 라이브러리가 사용하는 메모리가 늘어날 수록 단편화 지속됨 (그림 12.2)

- 재배치성
  - 지능적인 로더를 사용해서 메모리에 재배치할 수 있는 형태의 바이너리를 생성하도록 컴파일러를 수정
  - 컴파일러는 재배치 가능한 바이너리 안의 함수 이름을 메타데이터 형태로 생성
    - 라이브러리 함수를 호출한다면 컴파일러는 라이브러리 함수 이름을 외부 참조로 생성
    - 라이브러리 함수를 정의하는 프로그램이라면 컴파일러는 해당 이름을 외부 정의로 생성
      - 링킹 로더의 탄생

- 링커
  - 링킹 로더의 등장으로 프로그래머는 프로그램을 개별적으로 컴파일하고 로드할 수 있는 단위로 분할할 수 있었다.
  - 프로그램이 훨씬 커지게 되자 결국 링킹 로더 방식의 처리도 너무 느렸다.
  - 로드와 링크가 두 단계로 분리
    - 프로그래머가 느린 부분, 즉 링크 과정을 담당했는데, 링커라는 별도의 애플리케이션으로 이 작업을 처리
      - 링커는 링크가 완료된 재배치 코드를 만들어 줌 (로딩 과정이 아주 빨라짐)
  - 1980년대 소스 모듈은 .c 파일에서 .o 파일로 컴파일된 후, 링커로 전달되어 빠르게 로드될 수 있는 형태의 실행 파일로 만들어짐
    - 각 모듈의 컴파일 과정은 빨랐지만, 전체 모듈을 컴파일하는 일은 꽤 시간이 걸렸다.
  - 1980년 후반 무어의 법칙이 승리 ( 컴퓨터 속도, 메모리, 접적도가 매 18개월 마다 두배로 증가한다는 주장 )
    - 디스크는 작아지기 시작했고, 엄청 빨라짐.
    - 컴퓨터 메모리는 저렴해져서 디스크의 데이터를 모두 램에 캐싱
  - 1990년 후반에는 프로그램 성장 속도보다 링크 시간이 줄어드는 속도가 더 빨라졌다.
  - 이렇게 액티브 X와 공유 라이브러리 시대가 열렸고 .jar 파일도 등장했다.
    - 컴퓨터가 빨라져서 다시 로드와 링크를 동시에 할 수 있게 되었다.
  - **이렇게 컴포넌트 플러그인 아키텍처** 가 탄생했다.
  
- 결론
  - 런타임 플러그인 형태로 결합할 수 있는 동적 링크 파일이 소프트웨어 컴포넌트에 해당한다.


# 13장) 컴포넌트 응집도
- 서론
  - 어떤 클래스를 어느 컴포넌트에 포함시켜야 할까?
  - 컴포넌트 응집도와 관련된 세 가지 원칙
    - REP : 재사용/릴리스 등가 원칙
    - CCP : 공통 폐쇄 원칙 (SRP와 비슷)
    - CRP : 공통 재사용 원칙 (ISP와 비슷)

- REP:재사용/릴리스 등가 원칙
  - 재사용 단위는 릴리스 단위와 같다.
  - 재사용 가능한 컴포넌트가 많이 만들어짐에 따라 메이븐, 라이닝언, RVM 같은 모듈 관리 도구들이 등장했다.
  - 재사용을 위한 릴리즈 절차를 통해 추적 또는 릴리즈 번호 부여
    - 릴리스 번호가 없다면 재사용 컴포넌트들이 서로 호환되는지 보증할 방법이 전혀 없다.
      - 또한 새로운 버전이 언제 출시되고 무엇이 변했는지 소프트웨어 개발자들이 알아야 한다.
    - 릴리즈 변경 사항을 보고 기존 버전을 계속 쓸지 여부를 결정해야 되기 때문에 적절한 공지와 함께 릴리스 문서 작성도 포함되어야 한다.
  - 이 원칙을 소프트웨어 설계와 아키텍처 관점에서 보면 단일 컴포넌트는 응집성 높은 클래스와 모듈들로 구성되어야 한다.
  - 하나의 컴포넌트로 묶인 클래스와 모듈은 반드시 함께 릴리스할 수 있어야 한다. (버전 번호가 같아야 하며, 동일한 릴리스로 추적 관리되고, 동일한 릴리스 문서에 포함되어야 한다.)
    - 이치에 맞는 말이지만 클래스와 모듈을 단일 컴포넌트로 묶는 방법을 제대로 설명하기 힘들다.
    - REP에서 제대로 설명하기 힘든 부분을 CCP와 CRP이 지닌 강점을 통해 충분히 보완할 수 있다.
    
- CCP:공통 폐쇄 원칙
  - **동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶어라. 서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리하라.**
    - 이 원칙은 단일 책임 원칙(SRP)를 컴포넌트 관점에서 다시 쓴 것이다.
  - 대다수의 애플리케이션에서 유지보수성은 재사용성보다 훨씬 중요하다.
    - 코드가 반드시 변경되어야 한다면, 여러 컴포넌트에 분산되는것보다, 단일 컴포넌트에서 발생하는 편이 낫다.
    - 변경을 단일 컴포넌트로 제한할 수 있다면, 해당 컴포넌트만 재배포하면 된다.
  - CCP도 같은 이유로 변경 가능성이 있는 클래스는 모두 한곳으로 묶을 것을 권장한다.
    - 이를 통해 소프트웨어 릴리스, 재검증, 배포하는 일과 관련된 작업량을 최소화할 수 있다.
  - 개방 폐쇄 원칙(OCP)과도 밀접하게 관련되어 있다.
    - OCP에서는 클래스가 변경에는 닫혀 있고 확장에는 열려 있어야 한다고 말한다.
    - CCP에서는 동일한 유형의 변경에 대하 닫혀 있는 클래스들을 하나의 컴포넌트로 묶음으로써 OCP에서 얻은 교훈을 확대 적용한다.
    
    
  - **SRP와의 유사성**
    - SRP : 서로 다른 이유로 변경되는 메서드를 서로 다른 클래스로 분리하라
    - CCP : 서로 다른 이유로 변경되는 클래스를 서로 다른 컴포넌트로 분리하라
    - 두 원칙의 교휸
      - 동일한 시점에 동일한 이유로 변경되는 것들은 한데 묶어라. 서로 다른 시점에 다른 이유로 변경되는 것들은 서로 분리하라.
      
- CRP: 공통 재사용 원칙
  - **컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 말라.**
  - 공통 재사용 원칙(CRP)도 클래스와 모듈을 어느 컴포넌트에 위치시킬지 도움을 준다.
    - CRP에서 같이 재사용되는 경향이 있는 클래스와 모듈은 같은 컴포넌트에 포함해야 한다.
  - 대체로 재사용 가능한 클래스는 재사용 모듈의 일부로써 해당 모듈의 다른 클래스와 상호작용하는 경우가 많다.
    - ex)컨테이너 (Collection, Map)와 이터레이터
  - CRP는 각 컴포넌트에 어떤 클래스를 포함시켜야 하는지 뿐만 아니라 동일한 컴포넌트로 묶어서는 안되는 클래스가 무엇인지도 말해준다.
  - 컴포넌트가 다른 컴포넌트를 사용 시, 의존성이 생겨나고 이 같은 의존성으로 인해 사용되는 컴포넌트가 변경될 때마다 사용하는 컴포넌트도 변경해야 할 가능성이 높다.
    - 의존하는 컴포넌트가 있다면 해당 컴포넌트의 모든 클래스에 대해 의존함을 확실히 인지해야 한다.
      - 그렇지 않다면 필요 이상으로 많은 컴포넌트를 재배포하느라 리소스 낭비를 하게 된다.
      
  - **ISP와의 관계**
    - ISP : 사용하지 않은 메서드가 있는 클래스에 의존하지 말라
    - CRP : 사용하지 않는 클래스를 가진 컴포넌트에 의존하지 말라
    - 두 원칙의 교훈
      - 필요하지 않은 것에 의존하지 말라
      
- 컴포넌트 응집도에 대한 균형 다이어그램
  - REP와 CCP는 포함 원칙이다. 두 원칙은 컴포넌트를 더욱 크게 만든다.
  - CRP는 배제 원칙이며, 컴포넌트를 더욱 작게 만든다.
  - 그림 13.1) 결합도 원칙들의 균형 다이어그램
    - <img width="446" alt="다운로드" src="https://user-images.githubusercontent.com/7076334/97195949-3b08ff00-17ef-11eb-843d-37a32fae4738.png">
  - 뛰어난 아키텍트라면 이 균형 삼각형에서 개발팀이 현재 관심을 기울이는 부분을 충족시키는 부분을 찾아야 하며, 시간이 흐르면 주의를 기울이고 있는 부분도 변할 수 있다.
    - 프로젝트의 컴포넌트 구조는 시간과 성숙도에 따라 변한다.

- 결론
  - 컴포넌트 응집도에 관한 세 가지 원칙은 응집도가 가질 수 있는 훨씬 복잡한 다양성을 설명해 준다.
  - 이들 사이에서 애플리케이션의 요구에 맞게 유동적인 균형을 잡는 일은 중요하다. (시간에 따라 바뀔 수 있다.)

# 14장) 컴포넌트 결합



# 참고
- https://soohyeon317.tistory.com/entry/%EB%AA%A8%EB%85%B8%EB%A6%AC%ED%8B%B1Monolithic-vs-%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4Microservices
- https://thefif19wlsvy.tistory.com/24
