# 4부 컴포넌트 원칙
- SOLID 원칙이 벽과 방에 벽돌을 배치하는 방법을 알려준다면, 컴포넌트 원칙은 빌딩에 방을 배치하는 방법을 설명해 준다.


# 12장) 컴포넌트
- 서론
  - 시스템의 구성 요소로 배포할 수 있는 가장 작은 단위다.
    - 자바의 jar, 루비 gem, 닷넷 dll 
  - 여러 컴포넌트를 서로 링크하여 실행 가능한 단일 파일로 생성할 수 있다.
    - 여러 컴포넌트를 서로 묶어서 .war 파일과 같은 단일 아카이브로도 생성 가능
    - 컴포넌트 각각을 .jar, .dll 같이 동적으로 로드할 수 있는 플러그인이나 .exe 파일로 만들어 독립적으로 배포 가능
  - 잘 설계된 컴포넌트라면 반드시 독립적으로 배포 가능한/독립적으로 개발 가능한 능력을 갖춰야 한다.
  
- 컴포넌트의 간략한 역사
  - 소프트웨어 개발 초창기에는 메모리에서의 프로그램 위치와 레이아웃을 프로그래머가 직접 제어
    - 프로그램의 위치가 한번 결정되면, 재배치 불가
    - 라이브러리리 함수의 소스 코드를 애플리케이션 코드에 직접 포함시켜 단일로 컴파일 (라이브러리는 소스 코드 형태로 유지)
    - 메모리가 너무 작아서 소스 코드를 여러차례 읽어야만 했다.
  - 컴파일 시간을 단축시키기 위해 함수 라이브러리의 소스 코드를 애플리케이션 코드로부터 분리
    - 함수 라이브러리를 개별적으로 컴파일 하고 특정 위치에 로드했다.
    - 프로그램과 라이브러리가 사용하는 메모리가 늘어날 수록 단편화 지속됨 (그림 12.2)

- 재배치성
  - 지능적인 로더를 사용해서 메모리에 재배치할 수 있는 형태의 바이너리를 생성하도록 컴파일러를 수정
  - 컴파일러는 재배치 가능한 바이너리 안의 함수 이름을 메타데이터 형태로 생성
    - 라이브러리 함수를 호출한다면 컴파일러는 라이브러리 함수 이름을 외부 참조로 생성
    - 라이브러리 함수를 정의하는 프로그램이라면 컴파일러는 해당 이름을 외부 정의로 생성
      - 링킹 로더의 탄생

- 링커
  - 링킹 로더의 등장으로 프로그래머는 프로그램을 개별적으로 컴파일하고 로드할 수 있는 단위로 분할할 수 있었다.
  - 프로그램이 훨씬 커지게 되자 결국 링킹 로더 방식의 처리도 너무 느렸다.
  - 마침내 로드와 링크가 두 단계로 분리
    - 프로그래머가 느린 부분, 즉 링크 과정을 담당했는데, 링커라는 별도의 애플리케이션으로 이 작업을 처리
      - 링커는 링크가 완료된 재배치 코드를 만들어 줌 (로딩 과정이 아주 빨라짐)
  - 1980년대 소스 모듈은 .c 파일에서 .o 파일로 컴파일된 후, 링커로 전달되어 빠르게 로드될 수 있는 형태의 실행 파일로 만들어짐
    - 각 모듈의 컴파일 과정은 빨랐지만, 전체 모듈을 컴파일하는 일은 꽤 시간이 걸렸다.
  - 1980년 후반 무어의 법칙이 승리 ( 컴퓨터 속도, 메모리, 접적도가 매 18개월 마다 두배로 증가한다는 주장 )
    - 디스크는 작아지기 시작했고, 엄청 빨라짐.
    - 컴퓨터 메모리는 저렴해져서 디스크의 데이터를 모두 램에 캐싱
  - 1990년 후반에는 프로그램 성장 속도보다 링크 시간이 줄어드는 속도가 더 빨라졌다.
  - 이렇게 액티브 X와 공유 라이브러리 시대가 열렸고 .jar 파일도 등장했다.
    - 컴퓨터가 빨라져서 다시 로드와 링크를 동시에 할 수 있게 되었다.
  - **이렇게 컴포넌트 플러그인 아키텍처** 가 탄생했다.
  
- 결론
  - 런타임 플러그인 형태로 결합할 수 있는 동적 링크 파일이 소프트웨어 컴포넌트에 해당한다.


# 13장) 컴포넌트 응집도
- 서론
  - 어떤 클래스를 어느 컴포넌트에 포함시켜야 할까?
  - 컴포넌트 응집도와 관련된 세 가지 원칙
    - REP : 재사용/릴리스 등가 원칙
    - CCP : 공통 폐쇄 원칙 (설계원칙의 SRP, OCP와 비슷)
    - CRP : 공통 재사용 원칙 (설계원칙의 ISP와 비슷)

- REP:재사용/릴리스 등가 원칙
  - 재사용 단위는 릴리스 단위와 같다.
  - 재사용 가능한 컴포넌트가 많이 만들어짐에 따라 메이븐, 라이닝언, RVM 같은 모듈 관리 도구들이 등장했다.
  - 재사용을 위한 릴리즈 절차를 통해 추적 또는 릴리즈 번호 부여
    - 릴리스 번호가 없다면 재사용 컴포넌트들이 서로 호환되는지 보증할 방법이 전혀 없다.
      - 또한 새로운 버전이 언제 출시되고 무엇이 변했는지 소프트웨어 개발자들이 알아야 한다.
    - 릴리즈 변경 사항을 보고 기존 버전을 계속 쓸지 여부를 결정해야 되기 때문에 적절한 공지와 함께 릴리스 문서 작성도 포함되어야 한다.
  - 이 원칙을 소프트웨어 설계와 아키텍처 관점에서 보면 단일 컴포넌트는 응집성 높은 클래스와 모듈들로 구성되어야 한다.
  - 하나의 컴포넌트로 묶인 클래스와 모듈은 반드시 함께 릴리스할 수 있어야 한다. (버전 번호가 같아야 하며, 동일한 릴리스로 추적 관리되고, 동일한 릴리스 문서에 포함되어야 한다.)
    - 이치에 맞는 말이지만 클래스와 모듈을 단일 컴포넌트로 묶는 방법을 제대로 설명하기 힘들다.
    - REP에서 제대로 설명하기 힘든 부분을 CCP와 CRP이 지닌 강점을 통해 충분히 보완할 수 있다.
    
- CCP:공통 폐쇄 원칙
  - **동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶어라. 서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리하라.**
    - 이 원칙은 단일 책임 원칙(SRP)를 컴포넌트 관점에서 다시 쓴 것이다.
  - 대다수의 애플리케이션에서 유지보수성은 재사용성보다 훨씬 중요하다.
    - 코드가 반드시 변경되어야 한다면, 여러 컴포넌트에 분산되는것보다, 단일 컴포넌트에서 발생하는 편이 낫다.
    - 변경을 단일 컴포넌트로 제한할 수 있다면, 해당 컴포넌트만 재배포하면 된다.
  - CCP도 같은 이유로 변경 가능성이 있는 클래스는 모두 한곳으로 묶을 것을 권장한다.
    - 이를 통해 소프트웨어 릴리스, 재검증, 배포하는 일과 관련된 작업량을 최소화할 수 있다.
  - 개방 폐쇄 원칙(OCP)과도 밀접하게 관련되어 있다.
    - OCP에서는 클래스가 변경에는 닫혀 있고 확장에는 열려 있어야 한다고 말한다.
    - CCP에서는 동일한 유형의 변경에 대하 닫혀 있는 클래스들을 하나의 컴포넌트로 묶음으로써 OCP에서 얻은 교훈을 확대 적용한다.
    
  - **SRP와의 유사성**
    - SRP : 서로 다른 이유로 변경되는 메서드를 서로 다른 클래스로 분리하라
    - CCP : 서로 다른 이유로 변경되는 클래스를 서로 다른 컴포넌트로 분리하라
    - 두 원칙의 교휸
      - 동일한 시점에 동일한 이유로 변경되는 것들은 한데 묶어라. 서로 다른 시점에 다른 이유로 변경되는 것들은 서로 분리하라.
      
- CRP: 공통 재사용 원칙
  - **컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 말라.**
  - 공통 재사용 원칙(CRP)도 클래스와 모듈을 어느 컴포넌트에 위치시킬지 도움을 준다.
    - CRP에서 같이 재사용되는 경향이 있는 클래스와 모듈은 같은 컴포넌트에 포함해야 한다.
  - 대체로 재사용 가능한 클래스는 재사용 모듈의 일부로써 해당 모듈의 다른 클래스와 상호작용하는 경우가 많다.
    - ex)컨테이너 (Collection, Map)와 이터레이터
  - CRP는 각 컴포넌트에 어떤 클래스를 포함시켜야 하는지 뿐만 아니라 동일한 컴포넌트로 묶어서는 안되는 클래스가 무엇인지도 말해준다.
  - 컴포넌트가 다른 컴포넌트를 사용 시, 의존성이 생겨나고 이 같은 의존성으로 인해 사용되는 컴포넌트가 변경될 때마다 사용하는 컴포넌트도 변경해야 할 가능성이 높다.
    - 의존하는 컴포넌트가 있다면 해당 컴포넌트의 모든 클래스에 대해 의존함을 확실히 인지해야 한다.
      - 그렇지 않다면 필요 이상으로 많은 컴포넌트를 재배포하느라 리소스 낭비를 하게 된다.
      
  - **ISP와의 관계**
    - ISP : 사용하지 않은 메서드가 있는 클래스에 의존하지 말라
    - CRP : 사용하지 않는 클래스를 가진 컴포넌트에 의존하지 말라
    - 두 원칙의 교훈
      - 필요하지 않은 것에 의존하지 말라
      
- 컴포넌트 응집도에 대한 균형 다이어그램
  - REP와 CCP는 포함 원칙이다. 두 원칙은 컴포넌트를 더욱 크게 만든다.
  - CRP는 배제 원칙이며, 컴포넌트를 더욱 작게 만든다.
  - 그림 13.1) 결합도 원칙들의 균형 다이어그램
    - <img width="446" alt="다운로드" src="https://user-images.githubusercontent.com/7076334/97195949-3b08ff00-17ef-11eb-843d-37a32fae4738.png">
  - 뛰어난 아키텍트라면 이 균형 삼각형에서 개발팀이 현재 관심을 기울이는 부분을 충족시키는 부분을 찾아야 하며, 시간이 흐르면 주의를 기울이고 있는 부분도 변할 수 있다.
    - 프로젝트의 컴포넌트 구조는 시간과 성숙도에 따라 변한다.

- 결론
  - 컴포넌트 응집도에 관한 세 가지 원칙은 응집도가 가질 수 있는 훨씬 복잡한 다양성을 설명해 준다.
  - 이들 사이에서 애플리케이션의 요구에 맞게 유동적인 균형을 잡는 일은 중요하다. (시간에 따라 바뀔 수 있다.)


# 14장) 컴포넌트 결합
- 서론
  - 앞으로 다룰 세 가지 원칙은 컴포넌트 사이의 관계를 설명한다.
  - 이 장에서도 개발 가능성과 논리적 설계 사이의 균형을 다룬다.
  
- ADP(Acyclic Dependencies Principle):의존성 비순환 원칙
  - **컴포넌트 의존성 그래프에 순환(cycle)이 있어서는 안 된다.**
  - 숙취 증후군 : 정상 작동하던 부분이 누군가 의존하고 있던 무언가를 수정해서 동작하지 않는 현상
  - 프로젝트와 개발팀 규모가 커지면 숙취 증후군은 지독한 악몽이 될 수 있다.
    - 이를 해결하기 위해 첫번쨰는 '주 단위 빌드(weekly build)'이며, 두번째는 '의존성 비순환 원칙(Acyclic Dependencies Principle, ADP)' 이다.
    
  - **주 단위 빌드**
    - 중간 규모의 프로젝트에서 흔하게 사용된다.
    - 4일동안 개인 작업 하고, 금요일이 되면 변경된 코드를 통합하여 시스템을 빌드한다.
      - 통합이 점점 커질 수록 금요일 뿐만 아니라 토요일까지 지연되는 현상이 발생한다.
    - 개발보다 통합에 드는 시간이 늘어나면서 팀의 효율성도 서서히 나빠진다.
    - 효율성을 유지하기 위해 빌드 일정을 계속 늘려야 하고, 빌드 주기가 늦어질수록 프로젝트가 감수할 위험은 커진다.
      - 통합과 테스트를 수행하기 점점 더 어려워 지고, 팀은 빠른 피드백이 주는 장점을 잃는다.
      
  - **순환 의존성 제거하기**
    - 개발 환경을 릴리스 가능한 컴포넌트 단위로 분리하는 것이다.
      - 개별 개발자 또는 단일 개발자팀이 책임질 수 있는 작업 단위가 된다.
    - 1) 개발자가 컴포넌트를 릴리스 하여 다른 개발자가 사용할 수 있도록 만든다. (릴리스 번호 부여)
    - 2) 다른 팀에서는 새 릴리스를 적용할지 결정
      - 결국 어떤 팀도 다른 팀에 의해 좌우되지 않는다.
      - 이 절차가 성공적으로 동작하려면 컴포넌트 사이의 의존성 구조를 반드시 관리해야 한다. (순환이 있어는 안 된다.)
    - 그림 14.1) 전형적인 컴포넌트 다이어그램
      - 컴포넌트 간의 의존성 구조이고, 이 구조가 방향 그래프임에 주의하자. 컴포넌트는 정점에 해당하고, 의존성 관계는 방향이 있는 간선에 해당한다.
      - 어느 컴포넌트에서 시작하더라도 의존성 관계를 따라가면서 최초의 컴포넌트로 되돌아갈 수 없다. (비순환 방향 그래프)
      - 시스템 전체를 릴리스해야 할 때가 오면 릴리스 절차는 상향식으로 진행된다.
        - 컴파일 순서 : Entities -> Database, Interactors -> Presenters, View, Controllers, Authorizer -> Main 
   
  - **순환이 컴포넌트 의존성 그래프에 미치는 영향**
    - 그림 14.2) 순환 의존성
      - 순환은 의존성은 즉각적인 문제를 일으킨다.
        - Database -> Entities, Authorizer, Interactors 다 연관이 생긴다. (숙치 증후군)
        - 해당 컴포넌트 개발자들은 서로에게 얽매이게 되서, 모두 항상 정확하게 동일한 릴리스를 사용해야 된다.
    - 순환 의존성 문제
      - 컴포넌트 분리하기가 상당히 어려워진다.
      - 단위 테스트를 하고 릴리스 하는 일도 굉장히 어려워지며 에러도 쉽게 발생한다.
      - 모듈의 개수가 많아짐에 따라 빌드 관련 이슈는 기하급수적으로 증가한다.
      - 의존성 그래프에 순환이 생기면 컴포넌트를 어떤 순서로 빌드해야 올바를지 파악이 힘들어진다. (사실 순환 때문에 올바른 순서 자체가 없을 수도 있다.)
      
  - **순환 끊기**
    - 컴포넌트 사이의 순환을 끓고 다시 DAG(비순환)로 원상복구하는 일은 언제든 가능하다.
      - 1) 의존성 역전 원칙(DIP)을 적용한다.
        - ex) 그림 14.3
      - 2) Entities와 Authorizer가 모두 의존하는 새로운 컴포넌트를 만든다. 그리고 두 컴포넌트가 모두 의존하는 클래스들을 새로운 컴포넌트로 이동시킨다.
        - ex) 그림 14.4
        
  - **흐트러짐**
    - 두 번째 해결책에서 시사하는 바는 요구사항이 변경되면 컴포넌트 구조도 변경될 수 있다.
    - 실제 애플리케이션이 성장함에 따라 컴포넌트 의존성 구조는 선서히 흐트러지며 또 성장한다. ( 의존성 구조에 순환이 발생하는지 항상 관찰한다. )
      - 새로운 컴포넌트를 생성하거나 의존성 구조가 더 커질수도 있다.
      
- 하향식(top-down) 설계
  - 컴포넌트 구조는 하향식으로 설계될 수 없다.
    - 컴포넌트는 시스템에서 가장 먼저 설계할 수 있는 대상이 아니며, 오히려 시스템이 성장하고 변경될 때 함께 진화한다.
  - 컴포넌트 의존성 다이어그램은 애플리케이션의 기능을 기술하는것과 관계 없으며, 애플리케이션의 빌드 가능성과 유지보수성을 보여주는 지도와 같다.
    - 컴포넌트 구조는 프로젝트 초기에 설계할 수 없다.
  - 구현과 설계가 이뤄지는 프로젝트 초기에 모듈들이 점차 쌓이기 시작하면 '숙취 중후군'을 겪지 않고 프로젝트를 개발하기 위해서 의존성 관리에 대한 요구가 점차 늘어난다.
    - 결국 단일 책임 원칙(SRP)과 공통 폐쇄 원칙(CCP)에 관심을 갖기 시작하고, 이를 적용해 함께 변경되는 클래스는 같은 위치에 배치되도록 한다.
  - 의존성 구조와 관련된 최우선 관심사는 변동성을 격리하는 일이다.
  - 애플리케이션이 계속 성장함에 따라 우리는 재사용 가능한 요소룰 만드는 일에 관심을 기울이기 시작한다.
    - 이 시점에는 컴포넌트 조합하는 과정에서 공통 재사용 원칙(CRP)이 영향을 미치기 시작한다. 결국 순환이 발생하면 ADP가 적용되고, 컴포넌트 의존성 그래프는 조금씩 흐트러지고 또 성장한다.
  - 컴포넌트 의존성 구조는 시스템의 논리적 설계에 발맞춰 성장하며 또 진화해야 한다.
  
- SDP(Stable Dependencies Principle):안정된 의존성 원칙
  - **안정성의 방향으로(더 안정된 쪽에) 의존하라.**
  - 변경이 쉽지 않은 컴포넌트가 변동이 예상되는 컴포넌트에 의존하게 만들어서는 절대로 안 된다.
  - 안정된 의존성 원칙(SDP)을 준수하면 변경하기 어려운 모듈이 변경하기 쉽게 만들어진 모듈에 의존하지 않도록 만들 수 있다.
  
  - **안정성**
    - 소프트웨어 컴포넌트를 변경하기 어렵게 만드는 확실한 방법 하나는 수많은 다른 컴포넌트가 해당 컴포넌트에 의존하게 만드는 것이다.
    - 컴포넌트 안쪽으로 들어오는 의존성이 많아지면 상당히 안정적이라고 볼 수 있다.
      - 사소한 변경이라도 의존하는 모든 컴포넌트를 만족시키면서 변경하려면 상당한 노력이 든다.
    - <img width="434" alt="img" src="https://user-images.githubusercontent.com/7076334/97207039-deacdc00-17fc-11eb-9c2a-d0b93b32fc2b.png">
    
      - X는 안정된 컴포넌트다.
      - X는 세 컴포넌트를 책임진다.
      - X는 독립적이다.
  
    - <img width="433" alt="img2" src="https://user-images.githubusercontent.com/7076334/97207045-e0769f80-17fc-11eb-88c8-9ee2ce8401ca.png">
      
      - Y는 상당히 불안정한 컴포넌트다.
      - Y는 책임성이 없다.
      - Y는 의존적이다.
      
  - **안정성 지표**
    - 컴포넌트로 들어오고 나가는 의존성의 개수를 세어서, 이 숫자를 통해 컴포넌트가 위치상 어느 정도의 안정성을 가지는지 계산할 수 있다.
      - Fan-in : 안으로 들어 오는 의존성 
      - Fan-out : 바깥으로 나가는 의존성
      - I(불안정성) : I = Fan-out / (Fan-in + Fan-out).
        - [0,1] 범위의 값을 갖는다.
        - I=0 이면 최고로 안정된 컴포넌트
        - I=1 이면 최고로 불안정한 컴포넌트
      - I값이 1이면 (Fan-in=0) 어떤 컴포넌트도 해당 컴포넌트에 의존하지 않지만, 해당 컴포넌트는 다른 컴포넌트에 의존한다.(Fan-out>0)
        - 이러한 상태는 컴포넌트가 가질 수 있는 최고로 불안정한 상태
        - 이 컴포넌트는 책임성이 없으며 의존적이다. (변경 가능)
        - 반대로 이 컴포넌트가 다른 컴포넌트에 의존한다는 사실은 언젠가는 해당 컴포넌트를 변경해야 할 이유가 있다.
      - I값이 0이면 해당 컴포넌트에 의존하는 다른 컴포넌트가 있지만 (Fan-in>0), 해당 컴포넌트 자체는 다른 컴포넌트에 의존하지 않는다. (Fan-out=0)
        - 이러한 상태는 다른 컴포넌트를 책임지며 또 독립적이다.
        - 이러한 상태는 컴포넌트가 가질 수 있는 최고로 안정된 상태다.
        - 자신에게 의존하는 컴포넌트가 있으므로 해당 컴포넌트는 변경하기가 어렵지만, 해당 컴포넌트를 변경하도록 강제하는 의존성은 갖지 않는다.
      - SDP에서 컴포넌트의 I 지표는 그 컴포넌트가 의존하는 다른 컴포넌트들의 I보다 커야 한다고 말한다. 즉 의존성 방향으로 갈수록 I 지표 값이 감소해야 한다.
        
  - **모든 컴포넌트가 안정적이어야 하는 것은 아니다**
    - 모든 컴포넌트가 최고로 안정적인 시스템이라면 변경이 불가능하다. (바람직하지 않다.)
    - 그림 14.8) 세 컴포넌트로 구성된 시스템의 이상적인 구성
      - 위쪽에는 변경 가능한 컴포넌트가 보이고, 아래의 안정된 컴포넌트에 의존한다.
    - 그림 14.9) SDP 위배
      - Stable 컴포넌트에서 작업하던 개발자가 Flexible에 의존성을 걸게 되었다.
      - 이로 인해 SDP를 위배하는데, Stable의 I 지표는 Flexible의 I 지표보다 더 작기 떄문.
        - DIP를 도입하면 문제를 해결할 수 있다.
        
  - **추상 컴포넌트**
    - 추상 컴포넌트는 상당히 안정적이며, 따라서 덜 안정적인 컴포넌트가 의존할 수 있는 이상적인 대상이다.
    
- SAP:안정된 추상화 원칙
  - **컴포넌트는 안정된 정도만큼만 추상화되어야 한다.**
  
  - **고수준 정책을 어디애 위치시켜야 하는가?**
    - 시스템에는 자주 변경해서는 절대로 안 되는 소프트웨어도 있다. (고수준 아키텍처나 정책 결정 관련된 소프트웨어)
      - 고수준 정책을 캡슐화하는 소프트웨어는 반드시 안정된 컴포넌트(I=0)에 위치해야 한다.
    - 컴포넌트가 최고로 안정된 상태이면서도(I=0) 동시에 변경에 충분히 대응할 수 있을 정도로 유연하게 만들 수 있을까?
      - 추상 클래스를 이용하면 된다.
      
  - **안정된 추상화 원칙**
    - 안정된 추상화 원칙(SAP)은 안정과 추상화 정도 사이의 관계를 정의한다.
    - 안정적인 컴포넌트라면 반드시 인터페이스와 추상 클래스로 구성되어 쉽게 확장할 수 있어야 한다.
    - SAP와 SDP를 결합하면 컴포넌트에 대한 DIP나 마찬가지다.
      - SDP는 의존성이 반드시 안정성 방향으로 행해야 한다고 말한다.
      - SAP는 안정성이 결국 추상화를 의미한다고 말한다.
        - 결국 의존성은 추상화의 방향으로 향하게 된다.
      
  - **추상화 정도 측정하기**
    - Nc : 컴포넌트의 클래스 개수
    - Na : 컴포넌트의 추상 클래스와 인터페이스의 개수
    - A : 추상화 정도. A = Na / Nc
    - A 지표는 0과 1 사이의 값을 갖는다.
      - A가 0이면 컴포넌트에 추상 클래스가 하나도 없다.
      - A가 1이면 컴포넌트는 오로지 추상 클래스만을 포함한다.
      
  - **주게열**
    - 안정성(I)과 추상화 정도(A) 사이의 관계를 정의
      - <img width="330" alt="스크린샷 2020-10-27 오후 9 59 41" src="https://user-images.githubusercontent.com/7076334/97304978-d9ed3400-189f-11eb-8d8a-9d56f5df3814.png">
        
        - 최고로 안정적이며 추상화된 컴포넌트 구간 (0, 1)
        - 최고로 불안정하며 구체화된 컴포넌트 구간 (1, 0)
      
    - **고통의 구역**
      - 이 컴포넌트는 매우 안정적이며 구체적이다.
      - 추상적이지 않으므로 확장할 수 없고, 안정적이므로 변경하기도 상당히 어렵다.
      - 제대로 설계된 컴포넌트라면 (0,0) 근처에는 위치하지 않을 거라고 본다.
        - ex) 데이터베이스 스키마, 유틸리티 라이브러리
      - 변동성이 없는 컴포넌트는 (0,0) 구역에 위치했더라도 해롭지 않다.
      - 고통의 구역에서 문제가 되는 경우는 변동성이 있는 소프트웨어 컴포넌트다.
      
    - **쓸모없는 구역**
      - 여기 위치한 컴포넌트는 최고로 추상적이지만, 누구도 그 컴포넌트에 의존하지 않기 때문이다.
      - 이러한 엔티티는 누구도 구현하지 않은 채 남겨진 추상 클래스인 경우가 많다.
      
    - **배제 구역 벗어나기**
      - 주계열에 위치한 컴포넌트는 자신의 안정성에 비해 '너무 추상적' 이지도 않고, 추상화 정도에 비해 '너무 불안정'하지도 않다.
      - 컴포넌트가 추상화된 수준에 어울릴 정도로만 다른 컴포넌트가 의존하며, 구체화된 수준에 어올릴 정도로만 다른 컴포넌트에 의존한다.
      - 대규모 시스템에서 소수의 일부 컴포넌트는 완벽히 추상적이거나 완전하게 안정적일 수 없다. (주계열 바로 위에 또는 가깝게 위치하는게 이상적)

    - **주계열과의 거리**
      - D : 거리. D=|A+I-1|. 이 지표의 유효범위는 [0,1]이다. D가 0이면 컴포넌트가 주계열 바로 위에 위치한다는 뜻이며, 1이면 주계열로부터 가장 멀리 위치한다는 뜻이다.
      
- 결론
  - 의존성 관리 지표는 설계의 의존성과 추상화 정도가 내가 '훌륭한' 패턴이라고 생각하는 수준에 얼마나 잘 부합하는지를 측정한다.
      
    
# 참고
- https://soohyeon317.tistory.com/entry/%EB%AA%A8%EB%85%B8%EB%A6%AC%ED%8B%B1Monolithic-vs-%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4Microservices
- https://thefif19wlsvy.tistory.com/24
