# 33장 사례 연구:비디오 판매
### 서론
- 지금까지 살펴본 아키텍처에 대한 사례 연구

### 제품
- 웹사이트에서 비디오를 판매하는 소프트웨어
- 요구 조건
  - 개인과 기업에게 웹을 통해 비디오를 판매한다.
  - 개인은 단품으로 스트리밍을 보거나, 다운로드해서 영구 소장
  - 기업은 라이선스 구매해서 스트리밍만 가능하고, 대량 구매시 할인 가능
  
- 유스케이스 식별
  - 개인 : 시청자인 동시에 구매자
  - 기업 : 구매 대행하는 사람 따로 있음
  - 비디오 제작자 : 비디오 파일과 비디오에 대한 설명서, 부속 파일등 제공
  - 관리자 : 신규 비디오 시리즈 추천, 기존 시리즈 비디오를 추가 또는 삭제하며, 다양한 라이선스에 맞춰 가격 책정

### 유스케이스 분석
![usecase](https://user-images.githubusercontent.com/7076334/102012964-82901e00-3d90-11eb-9a6b-2ce74e2e8474.png)

- 액터
  - 단일 책임 원칙에 따르면 시스템이 변경되어야 할 네 가지 주요 근원이 되는 것으로 액터를 선정함
  - 특정 액터를 위한 변경이 나머지 액터에게는 전혀 영향을 미치지 않게 만드고자 함
- 간소화 시키기 위해 로그인이나 로그아웃 관련(includes - 실행 전제) 유스케이스는 제외
- 추상 유스케이스
  - 범용적인 정책을 담고 있으며, 다른 유스케이스에서 이를 더 구체화
  - 예제에서 추상 유스케이스가 꼭 필요한건 아니였지만 두 유스케이스가 너무 비슷해서, 유사성을 식별해서 분석 초기에 통합하는 방법을 찾는 편이 더 낫다고 판단

### 컴포넌트 아키텍처
![component architecture](https://user-images.githubusercontent.com/7076334/102013316-93419380-3d92-11eb-8bce-39d6f7b0c6cc.png)

- 액터와 유스케이스를 식별했으면, 예비 단계의 컴포넌트 아키텍처를 만들어 볼 수 있다. 

- 아키텍처 경계 (이중선)
  - 뷰, 프레젠터, 인터랙터, 컨트롤러로 분리 (의존성 규칙)
  - 대응하는 액터에 따라 카테고리를 분리 (단일 책임 원칙)
  
- 특수한 컴포넌트 Catalog View, Catalog Presenter(추상 컴포넌트)에 주목
  - 이 뷰와 프레젠터는 해당 컴포넌트 내부에 추상 클래스로 코드화 될 것이다.
  - 상속받는 컴포넌트에서는 이들 추상 클래스로부터 상속받은 뷰와 프레젠터 클래스를 포함
  
- jar나 dll을 어떻게 전달해야 할까?
  - 컴파일과 빌드 환경은 그림 33.2 형태로 나눌것이며, 각 컴포넌트를 독립적으로 전달할 수 있게 빌드하는 것도 가능
  - 전달해야 할 이 모든 단위를 더 적은 개수로 합칠 수도 있다.
    - 예를 들면 그림 33.2처럼 분할한 경우라면 뷰, 프레젠터, 인터랙터, 컨트롤러, 유틸리티 각각(총 5개)을 하나의 .jar파일로 만들 수 있다.
      - 서로 독립적으로 변경될 가능성이 큰 컴포넌트들을 독립적으로 배포할 수 있게 된다.
    - 뷰와 프레젠터를 합쳐서 같은 jar에 두고, 인터랙터, 컨트롤러, 유틸리티는 그대로 개별 jar 파일에 두는 방법
    - 뷰와 프레젠터를 합쳐서 같은 jar에 두고, 다른 하나에는 나머지 모두를 포함 시키는 방법

- 각 컴포넌트를 독립적으로 컴파일하고 빌드할 수 있는 환경을 구성하면 후에 시스템이 변경되는 양상에 맞춰 시스템 배포 방식을 조정할 수 있다.

### 의존성 관리
- 그림 33.2에서 제어흐름은 오른쪽에서 왼쪽으로 이동
- 모든 화살표가 오른쪽에서 왼쪽을 가리키지는 않는다.
  - 이는 아키텍처가 의존성 규칙을 준수하기 때문이다.
  - 모든 의존성은 경계선을 한 방향으로만 가로지르는데, 항상 더 높은 수준의(고수준) 정책을 포함하는 컴포넌트를 향한다.
- 개방 폐쇄 원칙
  - 사용 관계(열린 화살표)는 제어흐름과 같은 방향을 가리킨다.
  - 상속 관계(닫힌 화살표)는 제어흐름과는 반대 방향을 가리킨다.
    - 저수준의 세부사항에서 발생한 변경이 상위로 파급되어 상위 수준의 정책에 영향을 미치지 않음을 보장

### 결론
- 33.2의 아키텍처는 두 가지 서로 다른 차원의 분리 개념을 포함
  - 단일 책임 원칙에 기반한 액터의 분리
  - 의존성 규칙 (아키텍처 경계)
    - 이 두차원은 모두 서로 다른 이유로, 서로 다른 속도로 변경되는 컴포넌트를 분리하는 데 그 목적이 있다. (P.161 참고)
    - 서로 다른 이유는 액터와 관련이 있으며, 서로 다른 속도는 정책 수준과 관련이 있다.
- 이렇게 구조화하면 시스템을 실제 배포하는 방식을 다양하게 선택할 수 있게 된다.

- 궁금증
  - 컴포넌트 분리를 패키지로 처리해야 될까 모듈로 처리해야 될까?
  - jar로 묶는다면 특정 컴포넌트만 어떻게 선택할 수 있을까?

# 34장 빠져 있는 장
### 서론
- 앞의 조언들로 인해 설계된 소프트웨어는 올바르게 정의된 경계, 명확한 책임, 그리고 통제된 의존성을 가진 클래스와 컴포넌트로 구성될 것이다.
- 하지만 구현 세부사항에 대해 이점을 심사숙고하지 않는다면 마지막 고비에 걸려 넘어질 수 있다.

### 계층 기반 패키지
![34 1](https://user-images.githubusercontent.com/7076334/102018221-4a4c0800-3daf-11eb-863b-ca8982833cfd.png)
- 
 
