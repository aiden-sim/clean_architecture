# 33장 사례 연구:비디오 판매
### 서론
- 지금까지 살펴본 아키텍처에 대한 사례 연구

### 제품
- 웹사이트에서 비디오를 판매하는 소프트웨어
- 요구 조건
  - 개인과 기업에게 웹을 통해 비디오를 판매한다.
  - 개인은 단품으로 스트리밍을 보거나, 다운로드해서 영구 소장
  - 기업은 라이선스 구매해서 스트리밍만 가능하고, 대량 구매시 할인 가능
  
- 유스케이스 식별
  - 개인 : 시청자인 동시에 구매자
  - 기업 : 구매 대행하는 사람 따로 있음
  - 비디오 제작자 : 비디오 파일과 비디오에 대한 설명서, 부속 파일등 제공
  - 관리자 : 신규 비디오 시리즈 추천, 기존 시리즈 비디오를 추가 또는 삭제하며, 다양한 라이선스에 맞춰 가격 책정

### 유스케이스 분석
![usecase](https://user-images.githubusercontent.com/7076334/102012964-82901e00-3d90-11eb-9a6b-2ce74e2e8474.png)

- 액터
  - 단일 책임 원칙에 따르면 시스템이 변경되어야 할 네 가지 주요 근원이 되는 것으로 액터를 선정함
  - 특정 액터를 위한 변경이 나머지 액터에게는 전혀 영향을 미치지 않게 만드고자 함
- 간소화 시키기 위해 로그인이나 로그아웃 관련(includes - 실행 전제) 유스케이스는 제외
- 추상 유스케이스
  - 범용적인 정책을 담고 있으며, 다른 유스케이스에서 이를 더 구체화
  - 예제에서 추상 유스케이스가 꼭 필요한건 아니였지만 두 유스케이스가 너무 비슷해서, 유사성을 식별해서 분석 초기에 통합하는 방법을 찾는 편이 더 낫다고 판단

### 컴포넌트 아키텍처
![component architecture](https://user-images.githubusercontent.com/7076334/102013316-93419380-3d92-11eb-8bce-39d6f7b0c6cc.png)

- 액터와 유스케이스를 식별했으면, 예비 단계의 컴포넌트 아키텍처를 만들어 볼 수 있다. 

- 아키텍처 경계 (이중선)
  - 뷰, 프레젠터, 인터랙터, 컨트롤러로 분리 (의존성 규칙)
  - 대응하는 액터에 따라 카테고리를 분리 (단일 책임 원칙)
  
- 특수한 컴포넌트 Catalog View, Catalog Presenter(추상 컴포넌트)에 주목
  - 이 뷰와 프레젠터는 해당 컴포넌트 내부에 추상 클래스로 코드화 될 것이다.
  - 상속받는 컴포넌트에서는 이들 추상 클래스로부터 상속받은 뷰와 프레젠터 클래스를 포함
  
- jar나 dll을 어떻게 전달해야 할까?
  - 컴파일과 빌드 환경은 그림 33.2 형태로 나눌것이며, 각 컴포넌트를 독립적으로 전달할 수 있게 빌드하는 것도 가능
  - 전달해야 할 이 모든 단위를 더 적은 개수로 합칠 수도 있다.
    - 예를 들면 그림 33.2처럼 분할한 경우라면 뷰, 프레젠터, 인터랙터, 컨트롤러, 유틸리티 각각(총 5개)을 하나의 .jar파일로 만들 수 있다.
      - 서로 독립적으로 변경될 가능성이 큰 컴포넌트들을 독립적으로 배포할 수 있게 된다.
    - 뷰와 프레젠터를 합쳐서 같은 jar에 두고, 인터랙터, 컨트롤러, 유틸리티는 그대로 개별 jar 파일에 두는 방법
    - 뷰와 프레젠터를 합쳐서 같은 jar에 두고, 다른 하나에는 나머지 모두를 포함 시키는 방법

- 각 컴포넌트를 독립적으로 컴파일하고 빌드할 수 있는 환경을 구성하면 후에 시스템이 변경되는 양상에 맞춰 시스템 배포 방식을 조정할 수 있다.

### 의존성 관리
- 그림 33.2에서 제어흐름은 오른쪽에서 왼쪽으로 이동
- 모든 화살표가 오른쪽에서 왼쪽을 가리키지는 않는다.
  - 이는 아키텍처가 의존성 규칙을 준수하기 때문이다.
  - 모든 의존성은 경계선을 한 방향으로만 가로지르는데, 항상 더 높은 수준의(고수준) 정책을 포함하는 컴포넌트를 향한다.
- 개방 폐쇄 원칙
  - 사용 관계(열린 화살표)는 제어흐름과 같은 방향을 가리킨다.
  - 상속 관계(닫힌 화살표)는 제어흐름과는 반대 방향을 가리킨다.
    - 저수준의 세부사항에서 발생한 변경이 상위로 파급되어 상위 수준의 정책에 영향을 미치지 않음을 보장

### 결론
- 33.2의 아키텍처는 두 가지 서로 다른 차원의 분리 개념을 포함
  - 단일 책임 원칙에 기반한 액터의 분리
  - 의존성 규칙 (아키텍처 경계)
    - 이 두차원은 모두 서로 다른 이유로, 서로 다른 속도로 변경되는 컴포넌트를 분리하는 데 그 목적이 있다. (P.161 참고)
    - 서로 다른 이유는 액터와 관련이 있으며, 서로 다른 속도는 정책 수준과 관련이 있다.
- 이렇게 구조화하면 시스템을 실제 배포하는 방식을 다양하게 선택할 수 있게 된다.

- 궁금증
  - 컴포넌트 분리를 패키지로 처리해야 될까 모듈로 처리해야 될까?
  - jar로 묶는다면 특정 컴포넌트만 어떻게 선택할 수 있을까?

# 34장 빠져 있는 장
### 서론
- 앞의 조언들로 인해 설계된 소프트웨어는 올바르게 정의된 경계, 명확한 책임, 그리고 통제된 의존성을 가진 클래스와 컴포넌트로 구성될 것이다.
- 하지만 구현 세부사항에 대해 이점을 심사숙고하지 않는다면 마지막 고비에 걸려 넘어질 수 있다.

### 계층 기반 패키지
![34 1](https://user-images.githubusercontent.com/7076334/102018221-4a4c0800-3daf-11eb-863b-ca8982833cfd.png)

- 수평 계층형 아키텍처
  - 가장 단순한 첫 번째 설계 방식은 전통적인 수평 계층형 아키텍처다.
  - 기술적인 관점에서 해당 코드가 하는 일에 기반해 그 코드를 분할
  - 계층 기반 패키지라고 부름

- '엄격한 계층형 아키텍처'의 경우 계층은 반드시 바로 아래 계층에만 의존해야 한다.
- 자바의 경우 계층은 주로 패키지로 구현

- 마틸 파울러의 이야기
  - 프레젠테이션 도메인 데이터 계층화에서 처음 시작하기에는 계층형 아키텍처가 적합하다고 얘기함
  - 문제는 소프트웨어가 커지고 복잡해지기 시작하면, 머지 않아 큰 그릇 세개에 모든 코드를 담기엔 부족하다는 사실을 깨닫고, 더 잘게 모듈화를 고민
  
- 엉클밥의 이야기
  - 계층형 아키텍처는 업무 도메인에 대해 아무것도 말해주지 않는다.
  - 전혀 다른 업무 도메인이라도 코드를 계층형 아키텍처로 보면, 웹, 서비스, 리포지터리로 구성된 모습이 비슷하게 보임
  
### 기능 기반 패키지
![34 2](https://user-images.githubusercontent.com/7076334/102018485-d6aafa80-3db0-11eb-8ced-6496b65a50a7.png)

- 서로 연관된 기능, 도메인 개념, 또는 Aggregate Root에 기반하여 수직의 얇은 조각으로 코드를 나누는 방식
- 그림 34.2
  - 인터페이스와 클래스는 이전과 같지만, 모두가 단 하나의 패키지에 속하게 된다.
  - '계층 기반 패키지'를 아주 간단히 리팩토링 했지만, 이제 코드의 상위 수준 구조가 업무 도메인이 무엇인지 알려 주게 된다. (패키지)
  - 유스케이스가 변경될 경우 변경해야 할 코드를 모두 찾는 작업이 더 쉬워진다. (퍼져 있지 않고 한 패키지 안에 있기 때문)

- 수평적 계층화와 수직적 계층화는 둘다 차선책이다.

### 포트와 어댑터
![34 3](https://user-images.githubusercontent.com/7076334/102018745-96e51280-3db2-11eb-8cd7-4c13b56adcfd.png)

- 엉클밥의 이야기
  - '포트와 어댑터', '육각형 아키텍처', '경계, 컨트롤러, 엔티티' 등의 방식으로 접근하는 이유는
  - 업무/도메인에 초점을 둔 코드가 프레임워크나 데이터베이스 같은 기술적인 세부 구현과 독립적이며 분리된 아키텍처를 만들기 위해

- 내부와 외부
  - '내부' 영역은 도메인 개념을 모두 포함하는 반면, '외부' 영역은 외부 세계(UI, 데이터베이스, 서드파티 통합)와의 상호작용을 포함
  - 주요 규칙은 '외부'가 '내부'에 의존하며, 절대로 그 반대가 되면 안된다.


![34 4](https://user-images.githubusercontent.com/7076334/102018786-d3b10980-3db2-11eb-90b3-6c60cb599998.png)

- 도메인이 내부(com.mycompany.myapp.domain, 나머지는 외부(controller, repository)
- 의존성도 '내부'를 향해 흐른다. (의존 역전 제어)
- 도메인 주도 설계 명명법을 보면 '내부'에 존재하는 모든 것의 이름은 반드시 **유비쿼터스 도메인 언어** 관점에서 기술하라
  - ex) OrdersRepository -> Orders
  
### 컴포넌트 기반 패키지
- 컴포넌트 기반 패키지
  - SOLID, REP, CCP, CRP등 대다수의 조언에 대해 동감하지만, 코드를 조직화 하는 방법에 대해서는 다소 다른 결론에 이르렀다고 함
  - 다른 선택지를 제시, 이 방법은 **컴포넌트 기반 패키지** 라 부른다.
  - 지은이의 프로젝트 대부분 전통적인 계층형 아키텍처 기반으로 했다고 얘기하고 있다.
  
- 계층형 아키텍처가 좋지 않은점
  - 계층형 아키텍처의 목적은 기능이 같은 코드끼리 서로 분리한다.
    - 웹 / 업무 로직 / 데이터 접근
  - 서로 같은 업무 관련 코드라고 해도 서로 다른 패키지에 속하기 때문에 public하게 선언되어야 한다.
  
- 엄격한 계층형 아키텍처
  - 의존성 화살표는 항상 아래를 향해야 하며, 각 계층은 반드시 바로 아래 계층만 의존해야 한다.
  - 이런 방식은 멋지고 깔끔한 비순환 의존성 그래프를 만들 수 있을거라 생각할 수 있지만, 몇 가지 규칙을 반드시 지켜야 한다.
  - 속임수를 써서 몇몇 의존성을 의도치 않은 방식으로 추가하더라도, 보기에는 여전히 좋은 비순환 의존성 그래프가 생성된다.


![34 5](https://user-images.githubusercontent.com/7076334/102019228-97cb7380-3db5-11eb-8645-0d444b38fae1.png)

- 신규 인력의 유스케이스 구현 예제
  - OrdersController => OrdersRepository 직접 접근 (그림 34.5)
  - 이러한 조직화는 계층가 인접한 계층을 건너뛰는 일이 허용되기 떄문에 흔히 **완화된 계층형 아키텍처** 라고 부른다.
    - CQRS 패턴을 지키기 위해 의도적인 경우이고 이외의 경우 업무 로직 계층을 우회하는 일은 바람직하지 못함
    - 개별 레코드에 대한 인증된 접근만 허용하는 일을 업무 로직이 책임지는 경우라면 더더욱 그렇다.
    
- 느슨한 강제성 (문제점)
  - 여기서 우리에게 필요한 것은 지침으로, '웹 컨트롤러는 절대로 리포지터리에 직접 접근해서는 안 된다'와 같은 **원칙** 이 필요하다.
  - 훌륭한 규율, 코드리뷰등을 통해서 이 원칙을 강제하려고 하나, 자금이 바닥나거나 납기가 다가오면 무슨일이 벌어질지를 우리는 이미 잘 알고 있다.
  
- 정적 분석 도구를 통한 강제성 (문제점)
  - 정적 분석 도구(NDepend, Structure101, Checkstyle)를 사용해서 web 패키지에 있는 타입은 절대로 data에 있는 타입에 접근해서는 안 된다.
  - 이들 규칙은 컴파일 단계가 끝난 후 실행된다.
  - 다소 조잡하지만 효과는 있음. 위반 시 빌드가 실패
  
- 위 두 강제성 접근법 모두 오류가 있을 수 있으며, 그 결과를 알게 되는 주기가 필요 이상으로 길다.
  - 지은이는 가능하면 컴파일러를 사용해서 아키텍처를 강제하는 방식을 선호한다고 한다.
  
- '컴포넌트 기반 패키지'를 도입해야 하는 이유
  - 우리가 본 모든 것들을 혼합한 것으로, 큰 단위의 단일 컴포넌트와 관련된 모든 책임을 하나의 자바 패키지로 묶는 데 주안점을 둔다.
  - 이 접근법은 서비스 중심적인 시각으로 소프트웨어 시스템을 바라보며, 마이크로서비스 아키텍처가 가진 시각과도 동일
  - 포트와 어댑터 처럼(웹을 전달 메커니즘으로 취급) 컴포넌트 기반 패키지에서도 사용자 인터페이스를 큰 단위의 컴포넌트로부터 분리해서 유지
  

![34 6](https://user-images.githubusercontent.com/7076334/102019923-605ec600-3db9-11eb-9190-c56475bcff0f.png)

- 이 접근법에서 '업무 로직'과 영속성 관련 코드를 하나로 묶는데, 이 묶음을 지은이는 '컴포넌트'라고 부른다.
 
- 엉클 밥의 컴포넌트 정의
  - 컴포넌트는 배포 단위다. 컴포넌트는 시스템의 구성 요소로, 배포할 수 있는 가장 작은 단위다. 자바의 경우 jar 파일이 컴포넌트다.
  
- 마틴(지은이)의 컴포넌트 정의
  - 컴포넌트는 멋지고 깔끔한 인터페이스로 감싸진 연관된 기능들의 묶음으로, 애플리케이션과 같은 실행 환경 내부에 존재한다.(고수준을 말하는듯)
  - 소프트웨어 시스템의 정적 구조를 컨테이너, 컴포넌트, 클래스(또는 코드)의 측면에서 계층적으로 생각하는 간단한 방법
  - 소프트웨어 시스템은 하나 이상의 컨테이너(웹 애플리케이션, 모바일 앱, 독립형 애플리케이션, 데이터베이스, 파일 시스템 등)로 구성되며 각 컨테이너는 하나 이상의 컴포넌트를 포함
  - 각 컴포넌트는 하나 이상의 클래스(또는 코드)로 구현
    - 각 컴포넌트가 개별 jar로 분리 여부는 직교적인 관심사다. (한 요소에서 발생한 변경이 다른 변경에 영향을 미치지 않을 때)
    
- 컴포넌트 기반 패키지 접근법의 이점
  - 주문과 관련된 무언가를 코딩해야 할때 오직 한 곳, OrdersComponent만 둘러보면 된다.
    - 여기서 부터 계속


### 참고
- DDD START Chatper6(201P) 에서는 추가적인 로직이 없을뿐더러 조회 전용 기능이어서 트랜잭션이 필요하지 않는 경우, 굳이 서비스를 만들 필요 없이 표현 영역에서 바로 조회 전용 기능을 사용해도 된다라고 되어 있다.
- https://songii00.github.io/2019/11/28/2019-11-28-CleanArchitecture%20Item%2034/






 
