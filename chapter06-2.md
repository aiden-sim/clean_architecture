# 33장 사례 연구:비디오 판매
### 서론
- 지금까지 살펴본 아키텍처에 대한 사례 연구

### 제품
- 웹사이트에서 비디오를 판매하는 소프트웨어
- 요구 조건
  - 개인과 기업에게 웹을 통해 비디오를 판매한다.
  - 개인은 단품으로 스트리밍을 보거나, 다운로드해서 영구 소장
  - 기업은 라이선스 구매해서 스트리밍만 가능하고, 대량 구매시 할인 가능
  
- 유스케이스 식별
  - 개인 : 시청자인 동시에 구매자
  - 기업 : 구매 대행하는 사람 따로 있음
  - 비디오 제작자 : 비디오 파일과 비디오에 대한 설명서, 부속 파일등 제공
  - 관리자 : 신규 비디오 시리즈 추천, 기존 시리즈 비디오를 추가 또는 삭제하며, 다양한 라이선스에 맞춰 가격 책정

### 유스케이스 분석
![usecase](https://user-images.githubusercontent.com/7076334/102012964-82901e00-3d90-11eb-9a6b-2ce74e2e8474.png)

- 액터
  - 단일 책임 원칙에 따르면 시스템이 변경되어야 할 네 가지 주요 근원이 되는 것으로 액터를 선정함
  - 특정 액터를 위한 변경이 나머지 액터에게는 전혀 영향을 미치지 않게 만드고자 함
- 간소화 시키기 위해 로그인이나 로그아웃 관련(includes - 실행 전제) 유스케이스는 제외
- 추상 유스케이스
  - 범용적인 정책을 담고 있으며, 다른 유스케이스에서 이를 더 구체화
  - 예제에서 추상 유스케이스가 꼭 필요한건 아니였지만 두 유스케이스가 너무 비슷해서, 유사성을 식별해서 분석 초기에 통합하는 방법을 찾는 편이 더 낫다고 판단

### 컴포넌트 아키텍처
![component architecture](https://user-images.githubusercontent.com/7076334/102013316-93419380-3d92-11eb-8bce-39d6f7b0c6cc.png)

- 액터와 유스케이스를 식별했으면, 예비 단계의 컴포넌트 아키텍처를 만들어 볼 수 있다. 

- 아키텍처 경계 (이중선)
  - 뷰, 프레젠터, 인터랙터, 컨트롤러로 분리 (의존성 규칙)
  - 대응하는 액터에 따라 카테고리를 분리 (단일 책임 원칙)
  
- 특수한 컴포넌트 Catalog View, Catalog Presenter(추상 컴포넌트)에 주목
  - 이 뷰와 프레젠터는 해당 컴포넌트 내부에 추상 클래스로 코드화 될 것이다.
  - 상속받는 컴포넌트에서는 이들 추상 클래스로부터 상속받은 뷰와 프레젠터 클래스를 포함
  
- jar나 dll을 어떻게 전달해야 할까?
  - 컴파일과 빌드 환경은 그림 33.2 형태로 나눌것이며, 각 컴포넌트를 독립적으로 전달할 수 있게 빌드하는 것도 가능
  - 전달해야 할 이 모든 단위를 더 적은 개수로 합칠 수도 있다.
    - 예를 들면 그림 33.2처럼 분할한 경우라면 뷰, 프레젠터, 인터랙터, 컨트롤러, 유틸리티 각각(총 5개)을 하나의 .jar파일로 만들 수 있다.
      - 서로 독립적으로 변경될 가능성이 큰 컴포넌트들을 독립적으로 배포할 수 있게 된다.
    - 뷰와 프레젠터를 합쳐서 같은 jar에 두고, 인터랙터, 컨트롤러, 유틸리티는 그대로 개별 jar 파일에 두는 방법
    - 뷰와 프레젠터를 합쳐서 같은 jar에 두고, 다른 하나에는 나머지 모두를 포함 시키는 방법

- 각 컴포넌트를 독립적으로 컴파일하고 빌드할 수 있는 환경을 구성하면 후에 시스템이 변경되는 양상에 맞춰 시스템 배포 방식을 조정할 수 있다.

### 의존성 관리
- 그림 33.2에서 제어흐름은 오른쪽에서 왼쪽으로 이동
- 모든 화살표가 오른쪽에서 왼쪽을 가리키지는 않는다.
  - 이는 아키텍처가 의존성 규칙을 준수하기 때문이다.
  - 모든 의존성은 경계선을 한 방향으로만 가로지르는데, 항상 더 높은 수준의(고수준) 정책을 포함하는 컴포넌트를 향한다.
- 개방 폐쇄 원칙
  - 사용 관계(열린 화살표)는 제어흐름과 같은 방향을 가리킨다.
  - 상속 관계(닫힌 화살표)는 제어흐름과는 반대 방향을 가리킨다.
    - 저수준의 세부사항에서 발생한 변경이 상위로 파급되어 상위 수준의 정책에 영향을 미치지 않음을 보장

### 결론
- 33.2의 아키텍처는 두 가지 서로 다른 차원의 분리 개념을 포함
  - 단일 책임 원칙에 기반한 액터의 분리
  - 의존성 규칙 (아키텍처 경계)
    - 이 두차원은 모두 서로 다른 이유로, 서로 다른 속도로 변경되는 컴포넌트를 분리하는 데 그 목적이 있다. (P.161 참고)
    - 서로 다른 이유는 액터와 관련이 있으며, 서로 다른 속도는 정책 수준과 관련이 있다.
- 이렇게 구조화하면 시스템을 실제 배포하는 방식을 다양하게 선택할 수 있게 된다.

- 궁금증
  - 컴포넌트 분리를 패키지로 처리해야 될까 모듈로 처리해야 될까?
  - jar로 묶는다면 특정 컴포넌트만 어떻게 선택할 수 있을까?

# 34장 빠져 있는 장
### 서론
- 앞의 조언들로 인해 설계된 소프트웨어는 올바르게 정의된 경계, 명확한 책임, 그리고 통제된 의존성을 가진 클래스와 컴포넌트로 구성될 것이다.
- 하지만 구현 세부사항에 대해 이점을 심사숙고하지 않는다면 마지막 고비에 걸려 넘어질 수 있다.

### 계층 기반 패키지
![34 1](https://user-images.githubusercontent.com/7076334/102018221-4a4c0800-3daf-11eb-863b-ca8982833cfd.png)

- 수평 계층형 아키텍처
  - 가장 단순한 첫 번째 설계 방식은 전통적인 수평 계층형 아키텍처다.
  - 기술적인 관점에서 해당 코드가 하는 일에 기반해 그 코드를 분할
  - 계층 기반 패키지라고 부름

- '엄격한 계층형 아키텍처'의 경우 계층은 반드시 바로 아래 계층에만 의존해야 한다.
- 자바의 경우 계층은 주로 패키지로 구현

- 마틸 파울러의 이야기
  - 프레젠테이션 도메인 데이터 계층화에서 처음 시작하기에는 계층형 아키텍처가 적합하다고 얘기함
  - 문제는 소프트웨어가 커지고 복잡해지기 시작하면, 머지 않아 큰 그릇 세개에 모든 코드를 담기엔 부족하다는 사실을 깨닫고, 더 잘게 모듈화를 고민
  
- 엉클밥의 이야기
  - 계층형 아키텍처는 업무 도메인에 대해 아무것도 말해주지 않는다.
  - 전혀 다른 업무 도메인이라도 코드를 계층형 아키텍처로 보면, 웹, 서비스, 리포지터리로 구성된 모습이 비슷하게 보임
  
### 기능 기반 패키지
![34 2](https://user-images.githubusercontent.com/7076334/102018485-d6aafa80-3db0-11eb-8ced-6496b65a50a7.png)

- 서로 연관된 기능, 도메인 개념, 또는 Aggregate Root에 기반하여 수직의 얇은 조각으로 코드를 나누는 방식
- 그림 34.2
  - 인터페이스와 클래스는 이전과 같지만, 모두가 단 하나의 패키지에 속하게 된다.
  - '계층 기반 패키지'를 아주 간단히 리팩토링 했지만, 이제 코드의 상위 수준 구조가 업무 도메인이 무엇인지 알려 주게 된다. (패키지)
  - 유스케이스가 변경될 경우 변경해야 할 코드를 모두 찾는 작업이 더 쉬워진다. (퍼져 있지 않고 한 패키지 안에 있기 때문)

- 수평적 계층화와 수직적 계층화는 둘다 차선책이다.

### 포트와 어댑터
![34 3](https://user-images.githubusercontent.com/7076334/102018745-96e51280-3db2-11eb-8cd7-4c13b56adcfd.png)

- 엉클밥의 이야기
  - '포트와 어댑터', '육각형 아키텍처', '경계, 컨트롤러, 엔티티' 등의 방식으로 접근하는 이유는
  - 업무/도메인에 초점을 둔 코드가 프레임워크나 데이터베이스 같은 기술적인 세부 구현과 독립적이며 분리된 아키텍처를 만들기 위해

- 내부와 외부
  - '내부' 영역은 도메인 개념을 모두 포함하는 반면, '외부' 영역은 외부 세계(UI, 데이터베이스, 서드파티 통합)와의 상호작용을 포함
  - 주요 규칙은 '외부'가 '내부'에 의존하며, 절대로 그 반대가 되면 안된다.


![34 4](https://user-images.githubusercontent.com/7076334/102018786-d3b10980-3db2-11eb-90b3-6c60cb599998.png)

- 도메인이 내부(com.mycompany.myapp.domain, 나머지는 외부(controller, repository)
- 의존성도 '내부'를 향해 흐른다. (의존 역전 제어)
- 도메인 주도 설계 명명법을 보면 '내부'에 존재하는 모든 것의 이름은 반드시 **유비쿼터스 도메인 언어** 관점에서 기술하라
  - ex) OrdersRepository -> Orders
  

### 참고
- https://songii00.github.io/2019/11/28/2019-11-28-CleanArchitecture%20Item%2034/






 
