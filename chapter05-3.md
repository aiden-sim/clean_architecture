# 22장 클린 아키텍처
### 서론
  - 지난 수십 년간 육각형 아키텍처, DCI, BCE등 여러가지 시스템 아키텍처가 존재
    - 이들의 목표는 관심사의 분리다.
    - 이들 아키텍처 모두 시스템이 다음과 같은 특징을 지니게 만듬
      - 프레임워크 독립성 : 프레임워크의 존재 여부에 의존하지 않음
      - 테스트 용이성 : 외부 요소가 없이도 테스트 가능
      - UI 독립성 : 시스템 나머지 부분 변경없이 UI를 쉽게 변경 가능
      - 데이터베이스 독립성 : 데이터베이스에 결합되지 않기 때문에 여러 DB로 교체 가능
      - 모든 외부 에이전시에 대한 독립성 : 업무 규칙은 외부 세계와의 인터페이스에 대해 전혀 알지 못함

  - 클린 아키텍처
    - ![클린아키텍처](https://user-images.githubusercontent.com/7076334/99390482-0aaf0f00-291c-11eb-8c59-118ce939fd43.jpeg)

### 의존성 규칙
  - 바깥쪽 원은 메커니즘(저수준)이고, 안쪽 원은 정책(고수준)이다.
  - 이런 아키텍처가 동작하도록 하는 가장 중요한 규칙은 의존성 규칙이다.
    - 소스 코드 의존성은 반드시 안쪽으로, 고수준의 정책을 향해야된다.
  - 내부 원에 속한 요소는 외부 원에 속한 어떤 것도 알면 안된다.
 
### 엔티티
  - 엔티티는 전사적인 핵심 엄무 규칙을 캡슐화한다.
  - 다양한 애플리케이션에서 엔티티를 재사용할 수 있다면, 형태는 중요하지 않다.
  - 단순한 단일 애플리케이션 경우 엔티티는 업무 객체가된다. (고수준)
  - 운영 관점에서 특정 애플리케이션의 변경이 엔티티 계층에 절대로 영향을 주어서는 안된다.
  
### 유스케이스
  - 유스케이스는 애플리케이션에 특화된 업무 규칙을 포함한다.
  - 유스케이스는 엔티티로 들어오고 나가는 데이터 흐름을 조정하며, 엔티티가 자신의 핵심 업무 규칙을 사용해서 유스케이스의 목적 달성하도록 도와준다.
  - 유스케이스의 변경이 엔티티에 영향을 줘서는 안 된다.
  - 데이터 베이스, UI등 외부 요소 변경이 유스케이스에 영향을 줘서도 안 된다.
  - 운영 관점에서 애플리케이션의 변경된다면 유스케이스가 영향을 받는다.
  
### 인터페이스 어댑터
  - 일련의 어댑터들로 구성되어 있고, 어댑터는 유스케이스와 엔티티에게 가장 편리한 형식에서 데이터베이스나 웹 같은 외부 에이전시에게 가장 편리한 형식으로 변환
    - MVC 아키켁처를 모두 포괄 (프리젠터, 뷰, 컨트롤러)
  - 데이터를 유스케이스에게 가장 편리한 형식에서 영속성용으로 사용 중인 임의 프레임워크(데이터베이스)가 이용하기에 가장 편리한 형식으로 변환
    - 이 계층의 어떤 코드도 데이터베이스에 대해 절대 알아서 안된다.
  - 데이터를 외부 서비스와 같은 외부적인 형식에서 유스케이스나 엔티티에서 사용되는 내부적인 형식으로 변환하는 또 다른 어댑터가 필요
  
### 프레임워크와 드라이버
  - 데이터베이스나 웹 프레임워크 같은 프레임워크나 도구들로 구성된다.
  - 안쪽 원과 접합 코드 외에는 특별한 코드가 많지 않다.
  - 웹, 데이터베이스 같은 세부사항이 위치한다.
  
### 원은 네 개여야만 하나?
  - 네 개만 사용해야된다는 규칙은 없으나 어떤 경우에도 의존성 규칙은 적용된다.
    - 의존성은 항상 안쪽을 향한다. (저수준 -> 고수준)
  
### 경계 횡단하기
  - 그림 22.1 에서 제어 흐름은 컨트롤러에서 시작해, 유스케이스를 지난 후, 프레젠터에서 실행되며 마무리된다.
  - 각 의존성은 유스케이스를 향해 안쪽을 가리킨다.
  - 이처럼 제어흐름과 의존성의 방향이 반대여야 하는 경우 대체로 의존성 역전 원칙을 사용하여 해결한다.
    - 제어흐름을 따라 구현하면 안쪽 원의 코드가 바깥쪽 원의 코드를 호출하게 되는데 의존성을 역전시켜서, 바깥쪽의 원이 안쪽 원의 코드를 호출하게 만든다.
  - 동적 다형성을 이용하여 소스 코드 의존성을 제어흐름과 반대로 만들 수 있고, 이를 통해 제어흐름이 어느 방향으로 흐르더라도 의존성 규칙을 준수할 수 있다.
  
### 경계를 횡단하는 데이터는 어떤 모습인가
  - 경계를 가로지르는 데이터는 간단한 데이터 구조로 이루어져 있다.
    - 구조체나, 데이터 전송 객체(DTO)
    - 함수를 호출할 때 간단한 인자를 사용해서 데이터로 전달할 수도있고, 해시맵으로 묶거나 객체로 구성할 수도 있다.
      - 중요한 점은 격리되어 있는 간단한 데이터 구조가 경계를 가로질러 전달된다.
        - 엔티티 객체나 데이터베이스 행을 전달 시켜서는 안됨. (내부의 원에서 외부원의 무언가를 알아야 하기 때문에 의존성 규칙을 위배)
  - 경계를 가로질러 데이터를 전달 시, 데이터는 항상 내부의 원에서 사용하기에 가장 편리한 형태를 가져야 한다.
  
### 전형적인 시나리오
  - 그림 22.2
    - 여기서 데이터 제어 흐름 방향으로 처리하면 고수준 -> 저수준을 참조 하는 형태가 되기 때문에 인터페이스를 통한 의존성 역전 원칙을 사용했다.
    - 모든 의존성은 경계선을 안쪽으로 가로지르며, 따라서 의존성 규칙을 준수하고 있다.
    
### 결론
  - 소프트웨어를 계층으로 분리하고 의존성 규칙을 준수한다면 본질적으로 테스트하기 쉬운 시스템을 만들게 될 것이다.
  - 이에 따른 이점은 데이터베이스나 웹 프레임워크 같은 시스템을 쉽게 교체할 수 있다.
  

# 23장 프레젠터와 험블 객체
### 서론
  - 프레젠터 역할은 OuputData를 ViewModel과 같이 화면에 출력할 수 있는 형식으로 재구성
  - 프레젠터는 험블 객체 패턴을 따른 형태로 아키텍처 경계를 식별하고 보호하는데 도움이 됨
  
### 험블 객체 패턴
  - 디자인 패턴으로, 테스트하기 어려운 행위와 테스트하기 쉬운 행위를 단위 테스트 작성자가 분리하기 쉽게 하는 방법으로 고안됨
  - 모듈을 두개로 나누어(이중 하나가 험블) 테스트하기 어려운 행위를 험블 객체로 옮기고, 나머지는 테스트하기 쉬운 행위를 모두 옮긴다.
  - 험블 객체 패턴을 사용하면 행위를 분리하여 프레젠터와 뷰라는 서로 다른 클래스로 만들 수 있다.
  
### 프레젠터와 뷰
  - 뷰는 험블 객체이고 테스트하기 어렵다.
    - GUI로 이동시키지만, 데이터를 직접 처리하지 않는다.
  - 프레젠터는 테스트하기 쉬운 객체다.
    - 애플리케이션으로부터 데이터를 받아 화면에 표현할 수 있는 포멧으로 만든다.
    - 이를 통해 뷰는 데이터를 화면으로 전달하는 간단한 일만 처리한다.
  - 애플리케이션에 어떤 데이터를 표시할 경우
    - 1. 애플리케이션에서 프레젠터로 Data 객체를 전달
    - 2. 프레젠터는 데이터를 적절한 문자열로 만들고, 뷰 모델에 담는다.
    - 3. 뷰는 뷰 모델에서 데이터를 찾아서 화면에 출력한다.
      - 뷰는 뷰모델의 데이터를 화면으로 로드할 뿐이며, 이외 뷰가 맡은 역할은 전혀 없다.
      
### 테스트와 아키텍처
  - 테스트 용이성은 좋은 아키텍처가 지녀야 할 속성이다.
  - 앞에서 험블 객체 (테스트하기 쉬운 부분과 테스트하기 어려운 부분 분리로 경계 정의)를 예로 들었는데 이 밖에도 수많은 경계가 존재한다.
  
### 데이터베이스 게이트웨이
  - 유스케이스 인터랙터와 데이터베이스 사이에는 데이터베이스 게이트웨이가 위치함
    - 게이트웨이는 다형적 인터페이스로, 애플리케이션이 데이터베이스에 수행하는 생성, 조회, 갱신, 삭제 등의 모든 메서드 포함
  
### 데이터 매퍼
  - 객체 관계 매퍼같은건 사실 존재하지 않는다.
    - 객체는 데이터 구조가 아니기 때문이다.
    - 사용자 관점에서 볼때 객체는 단순히 오퍼레이션의 집합이다.
  - 객체와 달리 데이터 구조는 함축된 행위를 가지지 않는 public 데이터 변수의 집합이다.
  - 하이버네이트 같은 ORM은 어느 계층에 속하는가?
    - 데이터베이스 계층에 속한다.
    - 실제로 ORM은 게이트웨이 인터페이스와 데이터베이스 사이에서 일종의 험블 객체 경계를 형성한다.

### 서비스 리스너
  - 서비스에서도 험블 객체 패턴을 발견할 수 있을까? (당연)
    - 외부로 전달하는 경우
      - 애플리케이션은 데이터 구조 형태로 로드한 후, 이 데이터 구조를 경계를 가로질러 특정 모듈로 전달한다.
      - 해당 모듈은 데이터를 적절한 포맷으로 만들어 외부 서비스로 전달한다.
    - 외부로 데이터 수신하는 경우
      - 서비스 리스너가 서비스 인터페이스로부터 데이터를 수신하고, 애플리케이션에서 사용할 수 있게 간단한 데이터 구조로 포맷을 변경한다.
      - 그런 후 이 데이터 구조는 서비스 경계를 가로질러 내부로 전달된다.

### 결론
  - 아키텍처 경계마다 경계 가까이 숨어 있는 험블 객체 패턴을 발견할 수 있다.
  - 아키텍처 경계에서 험블 객체 패턴을 사용하면 전체 시스템의 테스트 용이성을 크게 높일 수 있다.

### 궁금한 부분
  - 험블 객체 패턴은 경계 분리 목적이 더 큰건가?

# 24장 부분적 경계
### 서론
  - 아키텍처 경계를 완벽하게 만드는 데는 비용이 많이 든다.
  - 뛰어난 아키텍트라면 이러한 경계를 만드는 비용이 너무 크다고 판단하면서도, 한편으로 나중에 필요할 수도 있으므로 이러한 경계에 필요한 공간을 확보하기 원할 수도 있다.
    - 선행적인 설계를 탐탁치 않는 사람도 많은데 일언 경우 **부분적 경계**를 구현해볼 수 있다.
    
### 마지막 단계를 건너띄기
  - 부분적 경계를 생성하는 방법 중 하나는 독립적으로 컴파일하고 배포할 수 있는 컴포넌트를 만들기 위한 작업은 모두 수행한 후, 단일 컴포넌트 그대로 모아만 두는 것이다.
  - 부분적 경계를 만들려면 완벽한 경계를 만들때 만큼의 코드량과 사전 설계가 필요하다.
    - 하지만 다수의 컴포넌트 관리하는 작업은 필요 없다. (이 차이는 크다)
  - FitNesse 사례를 설명하며 처음에는 컴포넌트 분리 후, 하나의 jar로 합쳐서 배포했지만 시간이 지날 수록 컴포넌트 사이의 구분도 약화되고, 의존성도 잘못되었다라고 한다.
  
### 일차원 경계
  - 완벽한 형태의 아키텍처 경계는 양방향으로 격리를 유지해야 하므로 쌍방향 Boundary 인터페이스를 사용한다.(비용이 많이 든다.)
  - 전략 패턴을 사용하여 추후 환벽한 형태의 경계로 확장할 수 있는 공간을 확보할 수 있다.
    - 하지만 점선 화살표(그림 24.1) 에서 보듯이 이러한 분리는 매우 빠르게 붕괴될 수 있다.
    - 쌍방향 인터페이스가 없고 개발자와 아키텍트가 제대로 훈련되어 있지 않다면, 점선(Service Impl->Client)을 막을 방법이 없다.
    
### 퍼사드
  - 퍼사드는 의존성 역전까지 희생하고 경계는 Facade 클래스로만 간단히 정의된다.
  - 클라이언트는 이들 서비스 클래스에 직접 접근할 수 없다.
    - 하지만 클라이언트가 이 모든 서비스 클래스에 대해 추이 종속성을 가지게 되었다. (A->B, B->C, A->C)
    - 정적 언어라면 하나의 소스 코드 변경되면 클라이언트도 무조건 재컴파일해야 된다.

### 결론
  - 이러한 접근법 각각은 나름의 비용과 장점을 지닌다.
  

  
  
  
  
  
