# 29장 클린 임베디드 아키텍처
### 서론
- **소프트웨어는 닳지 않지만, 펌웨어와 하드웨어는 낡아 가므로 결국 소프트웨어도 수정해야 한다.**
  - 소프트웨어는 긴 시간 유용하게 쓸 수 있는 반면, 펌웨어는 하드웨어가 발전할수록 낡아 갈 것이다.
  
- **덧) 소프트웨어는 닳지 않지만, 펌웨어와 하드웨어에 대한 의존성을 관리하지 않으면 안으로부터 파괴될 수 있다.**

- 펌웨어의 정의
  - 플래시 메모리 같은 비휘발성 메모리에 유지
  - 하드웨어 장치에 프로그래밍 된 소프트웨어
  - 하드웨어에 내장되는 소프트웨어
  - 읽기 전용 메모리(ROM)에 쓰여진 소프트웨어
   
- 코드에 SQL을 추가하는것 자체가 펌웨어 작성으로 보다니 신선했음

- 펌웨어를 수없이 양산하는 일을 멈추고, 코드에게 유효 수명을 길게 늘릴 수 있는 기회를 줘라

### 앱-티튜드 테스트
- 왜 펌웨어로 변할까? 구조화에 신경쓰지 않아서
- 켄트백의 소프트웨어 구축 3가지
  - 먼저 동작하게 만들어라. 
  - 그리고 올바르게 만들어라. 
  - 그리고 빠르게 만들어라.

- 그저 동작하게 만들면 소프트웨어 수명이 길지 않을 것이다.

- 글쓴이는 앱이 동작하도록 만드는 것을 개발자용 **앱-티튜드 테스트** 라고 부른다고 한다.
  - 임베디드 시스템의 한 파일을 찾아서 함수로 분류
  - 다른 파일에는 특정 임베디드 장치에서만 테스트할 수 있는 파일 구조를 포함
  - 코드를 특정 툴 체인과 마이크로프로세서에 구속해 버리는 '확장된' C 언어 구조 사용
    - 앱-티튜드 테스트를 통과했지만 클린 임베디드 아키텍처를 가진다고 할 수 없다.
    
### 타깃-하드웨어 병목현상
- 임베디드가 지닌 특수한 문제 중 하나는 타깃-하드웨어 병목현상이다.
  - 클린 아키텍처를 따르지 않고 작성된다면, 대개는 테스트 환경이 해당 특정 타깃으로 국한될 것이다.
  - 그리고 그 타깃이 테스트가 가능한 유일한 장소라면 타깃-하드웨어 병목 현상이 발생하여 진척이 느려질 것이다.
    - 테스트할 수 있는 장비가 한정되서 환경적인 요인등 병목될 수 있어서 느려진다고 이해했음
  
#### 클린 임베디드 아키텍처는 테스트하기 쉬운 임베디드 아키텍처다
- 아키텍처 원칙을 임베디드 소프트웨어와 펌웨어에 적용하여 타깃-하드웨어 병목현상을 줄이는 방법들


##### 계층
- 맨 하단이 하드웨어. 하드웨어는 기술의 발전과 무어의 법칙에 따라 변할 것이다.
  - 무어의 법칙 : 반도체 집적회로의 성능이 24개월마다 2배로 증가한다는 법칙이다. (https://ko.wikipedia.org/wiki/%EB%AC%B4%EC%96%B4%EC%9D%98_%EB%B2%95%EC%B9%99)
 
- 최소한 하드웨어가 정의된 이후라면 하드웨어와 나머지 시스템 사이의 분리는 주어진다. (그림 29.2)
  - 이 상태에서 앱-티튜드 테스트를 해보면 대체로 문제가 발생
  - 소프트웨어와 펌웨어가 서로 섞이는 일은 안티 패턴이다.
    - 변경하기 어려울 뿐 아니라 변경하는 일 자체가 위험을 수반한다.
    
##### 하드웨어는 세부사항이다.
- 소프트웨어와 펌웨어 사이의 경계는 코드와 하드웨어 사이의 경계와는 달리 잘 정의하기 힘들다. (그림 29.3)
- 소프트웨어와 펌웨어 사이의 경계는 **하드웨어 추상화 계층** 이라고 부른다.
  - ![스크린샷 2020-12-01 오전 2 00 40](https://user-images.githubusercontent.com/7076334/100639842-0a316200-3379-11eb-9c75-e55aa6d7ae7f.png)
  - HAL은 자신보다 위에 있는 소프트웨어를 위해 존재하므로, API는 소프트웨어의 필요에 맞게 만들어져야 한다.
  - 소프트웨어는 데이터가 어디에 저장되는지 개의치 않는다. 이러한 서비스는 HAL이 제공하며, 세부사항은 소프트웨어에게 드러내지 않는다.
  
#### HAL 사용자에게 하드웨어 세부사항을 드러내지 말자
- 클린 임베디드 아키텍처로 설계된 소프트웨어는 타깃 하드웨어에 관계없이 테스트 가능
- HAL을 제대로 만들었다면, 타깃에 상관없이 테스트할 수 있는 경계층 or 일련의 대체 지점 제공

##### 프로세서는 세부사항이다.
- 프로세서 제작업체가 제공하는 C컴파일러는 종종 전역변수를 제공하여 여러기능을 직접 접근하도록 해준다.
  - 이러한 기능을 사용해 버리면 다른 프로세서에서는 컴파일 되지 않을 것이다.
- 일부로 자신의 컴파일러에 종속되게 만들었다고는 생각하지 않는다. 미래를 망치지 않는 선에서 사용하는것은 당신의 몫이다. 
  - C를 확장한 요소를 아는 파일을 제한해야 한다.
- 에크미 예를 들며 헤더를 직접 사용하게 되면 코드가 종속되 버려서, 헤더가 없이 당신의 코드를 컴파일 할 수 없다고 말한다.
- 표준화된 stdint.h(정수 자료형)를 사용하게 하면 깔끔하며 이식 가능한 코드를 만들고 유지하는데 도움이 된다.
- 클린 임베디드 아키텍처라면 장치 접근 레지스터를 직접 사용하는 코드는 소수의, 순전히 펌웨어로만 한정시켜야 한다.
- 이러한 마이크로 컨트롤러를 사용할 때, 펌웨어가 저수준 함수들을 프로세서 추상화 계층(PAL)의 형태로 격리시켜줄 수 있다.
  - PAL 상위에 위치하는 펌웨어는 타깃-하드웨어 관계없이 테스트할 수 있게 되어, 펌웨어 자체도 좀 더 유연해 질 수 있다.
  
##### 운영체제는 세부사항이다.
- 깡통 임베디드 시스템이라면 HAL 만으로 깊숙이 종속되지 않게 제어가능.
- 하지만 운영체제를 사용한다면?
  - 무조건 운영체제를 세부사항으로 취급하고 의존하는 일을 막아야 코드의 수명을 늘릴 수 있다.
- OS는 소프트웨어를 펌웨어로 분리하는 계층(그림 29.5)
  - 예를 들어 OS를 다른 기업에서 인수한 경우
  
- 클린 임베디드 아키텍처는 운영체제 추상화 계층(Operating System Abstraction Layer)을 통해 소프트웨어를 운영체제로부터 격리시킨다.
  - ![스크린샷 2020-12-01 오전 2 47 29](https://user-images.githubusercontent.com/7076334/100645164-a2cae080-337f-11eb-8944-c9202ef7b005.png)
  - 소프트웨어가 OS에 직접적으로 의존하는 대신 OSAL에 의존하면, 이식 작업의 대부분은 기존 OSAL과 호환되도록 새로운 OSAL을 작성하는데 소요될 것이다.
  - 코드 비대화 문제가 걱정될 수도 있지만 실제로 이러한 중복이 그다지 큰 비용은 추가로 초래하지 않는다.
  - OSAL은 테스트 지점을 만드는데 도움이 되며, 애플리케이션 코드를 타깃이나 OS에 관계없이 테스트할 수 있게 된다.
  
#### 인터페이스를 통하고 대체 가능성을 높이는 방향으로 프로그래밍하라
- 모든 주요 계층(소프트웨어, OS, 펌웨어, 하드웨어) 내부에는 책에서 설명한 원칙들을 적용할 수 있다.(해라)
  - 관심사 분리, 인터페이스를 활용
  
- 계층형 아키텍처는 인터페이스를 통해 프로그래밍하자는 발상을 기반으로 한다.
  - 모듈들이 서로 인터페이스를 통해 상호작용한다면 특정 서비스 제공자를 다른 제공자로 대체가능
  
- 인터페이스 정의는 헤더 파일에 해야 하고, 함수 선언과 그 함수에서 사용하는 상수와 구조체 이름만 포함해야 된다.

- 오직 구현체에서만 필요한 데이터 구조, 상수, 타입 정의들로 인터펭피스 헤더 파일을 어지럽히지 말라
  - 원치 않는 의존성을 만들 수 있다.
  
- 클린 임베디드 아키텍처에서는 모듈들이 인터페이스를 통해 상호작용하기 때문에 각각의 계층 내부에서 테스트 가능하다.

#### DRY원칙:조건부 컴파일 지시자를 반복하지 말라
- 임베디드 시스템의 경우 타깃-하드웨어의 유형을 식별하는 조건부 컴파일을 반복해서 사용할 때가 많다.
- HAL이 조건부 컴파일 대신 사용할 수 있는 일련의 인터페이스를 제공한다면, 링커 또는 어떤 형태의 실시간 바인딩을 사용해서 소프트웨어를 하드웨어에 연결 가능

### 결론
- 클린 임베디드 아키텍처는 제품이 장기간 생명력을 유지하는 데 도움을 준다.
