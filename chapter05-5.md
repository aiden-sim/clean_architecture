# 29장 클린 임베디드 아키텍처
### 서론
- **소프트웨어는 닳지 않지만, 펌웨어와 하드웨어는 낡아 가므로 결국 소프트웨어도 수정해야 한다.**
  - 소프트웨어는 긴 시간 유용하게 쓸 수 있는 반면, 펌웨어는 하드웨어가 발전할수록 낡아 갈 것이다.
  
- **덧) 소프트웨어는 닳지 않지만, 펌웨어와 하드웨어에 대한 의존성을 관리하지 않으면 안으로부터 파괴될 수 있다.**

- 펌웨어의 정의
  - 플래시 메모리 같은 비휘발성 메모리에 유지
  - 하드웨어 장치에 프로그래밍 된 소프트웨어
  - 하드웨어에 내장되는 소프트웨어
  - 읽기 전용 메모리(ROM)에 쓰여진 소프트웨어
   
- 코드에 SQL을 추가하는것 자체가 펌웨어 작성으로 보다니 신선했음

- 펌웨어를 수없이 양산하는 일을 멈추고, 코드에게 유효 수명을 길게 늘릴 수 있는 기회를 줘라

### 앱-티튜드 테스트
- 왜 펌웨어로 변할까? 구조화에 신경쓰지 않아서
- 켄트백의 소프트웨어 구축 3가지
  - 먼저 동작하게 만들어라. 
  - 그리고 올바르게 만들어라. 
  - 그리고 빠르게 만들어라.

- 그저 동작하게 만들면 소프트웨어 수명이 길지 않을 것이다.

- 글쓴이는 앱이 동작하도록 만드는 것을 개발자용 **앱-티튜드 테스트** 라고 부른다고 한다.
  - 임베디드 시스템의 한 파일을 찾아서 함수로 분류
  - 다른 파일에는 특정 임베디드 장치에서만 테스트할 수 있는 파일 구조를 포함
  - 코드를 특정 툴 체인과 마이크로프로세서에 구속해 버리는 '확장된' C 언어 구조 사용
    - 앱-티튜드 테스트를 통과했지만 클린 임베디드 아키텍처를 가진다고 할 수 없다.
    
## 타깃-하드웨어 병목현상
- 임베디드가 지닌 특수한 문제 중 하나는 타깃-하드웨어 병목현상이다.
  - 클린 아키텍처를 따르지 않고 작성된다면, 대개는 테스트 환경이 해당 특정 타깃으로 국한될 것이다.
  - 그리고 그 타깃이 테스트가 가능한 유일한 장소라면 타깃-하드웨어 병목 현상이 발생하여 진척이 느려질 것이다.
    - 테스트할 수 있는 장비가 한정되서 환경적인 요인등 병목될 수 있어서 느려진다고 이해했음
  
### 클린 임베디드 아키텍처는 테스트하기 쉬운 임베디드 아키텍처다
- 아키텍처 원칙을 임베디드 소프트웨어와 펌웨어에 적용하여 타깃-하드웨어 병목현상을 줄이는 방법들


#### 계층
- 맨 하단이 하드웨어. 하드웨어는 기술의 발전과 무어의 법칙에 따라 변할 것이다.
  - 무어의 법칙 : 반도체 집적회로의 성능이 24개월마다 2배로 증가한다는 법칙이다. (https://ko.wikipedia.org/wiki/%EB%AC%B4%EC%96%B4%EC%9D%98_%EB%B2%95%EC%B9%99)
 
- 최소한 하드웨어가 정의된 이후라면 하드웨어와 나머지 시스템 사이의 분리는 주어진다. (그림 29.2)
  - 이 상태에서 앱-티튜드 테스트를 해보면 대체로 문제가 발생
  - 소프트웨어와 펌웨어가 서로 섞이는 일은 안티 패턴이다.
    - 변경하기 어려울 뿐 아니라 변경하는 일 자체가 위험을 수반한다.
    
#### 하드웨어는 세부사항이다.
- 소프트웨어와 펌웨어 사이의 경계는 코드와 하드웨어 사이의 경계와는 달리 잘 정의하기 힘들다. (그림 29.3)
- 소프트웨어와 펌웨어 사이의 경계는 **하드웨어 추상화 계층** 이라고 부른다.
  - ![스크린샷 2020-12-01 오전 2 00 40](https://user-images.githubusercontent.com/7076334/100639842-0a316200-3379-11eb-9c75-e55aa6d7ae7f.png)
  - HAL은 자신보다 위에 있는 소프트웨어를 위해 존재하므로, API는 소프트웨어의 필요에 맞게 만들어져야 한다.
  - 소프트웨어는 데이터가 어디에 저장되는지 개의치 않는다. 이러한 서비스는 HAL이 제공하며, 세부사항은 소프트웨어에게 드러내지 않는다.
  
### HAL 사용자에게 하드웨어 세부사항을 드러내지 말자
- 클린 임베디드 아키텍처로 설계된 소프트웨어는 타깃 하드웨어에 관계없이 테스트 가능
- HAL




  
  
  

