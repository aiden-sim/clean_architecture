# 18장 경계 해부학
- 서론
  - 시스템 아키텍처는 일련의 소프트웨어 컴포넌트와 그 컴포넌트들을 분리하는 경계에 의해 정의된다.
  
- 경계 횡단하기
  - 적절한 위치에서 경계를 횡단하게 하는 비결은 소스 코드 의존성 관리에 있다.
    - 소스 코드 모듈 하나가 변경되면, 이에 의존하는 다른 소스 코드 모듈도 변경하거나, 다시 컴파일해서 새로 배포해야 할지도 모른다.
  - 경계는 이러한 변경이 전파되는 것을 막는 방화벽을 구축하고 관리하는 수단으로써 존재
  
- 두려운 단일체(모노리틱)
  - 소스 수준 분리 모드
    - 함수와 데이터가 단일 프로세서에서 같은 주소 공간을 공유하며 나름의 규칙에 따라 분리
  - 배포 관점에서는 단일 실행 파일에 지나지 않는다. (링크, jar, EXE)
    - 단일 실행 파일을 만들더라고 그 안에 포함된 다양한 컴포넌트를 개발하고 바이너리로 만드는 과정을 독립적으로 수행할 수 있게 하는 것은 대단히 가치 있는 일이다.
  - 단일체 아키텍처는 대부분 동적 다형성에 의존하여 내부 의존성을 관리한다.
    - 동적 다형성이 없었더라면 함수 포인터를 사용해야 했고 위험하기 때문에 컴포넌트를 분리하려는 시도도 결국 포기했을 것이다.
  - 가장 단순한 형태의 경계 횡단은 저수준 클라이언트에서 고수준 서비스로 향하는 함수 호출
    - 런타임과 컴파일 의존성 방향이 같다. 
    - 그림 18.1)
  - 고수준 클라이언트가 저수준 서비스를 호출해야 한다면 동적 다형성을 사용하여 제어 흐름과는 반대로 방향으로 의존성 역전시킬 수 있다.
    - 런타임 의존성과 컴파일 의존성은 반대가 된다.
    - 그림 18.2) 
  - 정적 링크된 모노리틱 구조의 실행 파일도 이처럼 규칙적인 방식으로 구조를 분리하면 프로젝트 개발, 테스트, 배포하는 작업에 큰 도움이 된다.
    - 독립성이 유지된다.
  - 단일체의 컴포넌트간 통신은 매우 빠르고 값싸다.
  - 단일체의 배포는 소스 코드 형태로 전달된다.

- 배포형 컴포넌트
  - 아키텍처의 경계가 물리적으로 드러날 수도 있는데 그중 가장 단순한 형태는 동적 링크 라이브러리
    - ex) .NET DLL, 자바 jar, 루비 젬 등 (별도 컴파일 하지 않고 바로 사용 가능)
  - 배포 작업은 단순히 이들 배포 가능한 단위를 좀 더 편리한 형태로 묶는 역할
    - ex) WAR
  - 이러한 배포 과정에서만 차이가 날 뿐, 배포 수준의 컴포넌트는 단일체와 동일한다.
    - 하지만 정적 다형성을 사용할 수 없다. (컴파일시 이미 결정나기 때문에)
  - 단일체와 동일하게 컴포넌트간 통신은 매우 값싸다.
  
- 스레드
  - 스레드는 아키텍처 경계도 아니며 배포 단위도 아니다.
  - 스레드는 실행 계획과 순서를 체계화하는 방벙에 가깝다.
  
- 로컬 프로세스
  - 훨씬 강한 물리적 형태를 띠는 아키텍처 경계로 로컬 프로세스가 있다.
  - 로컬 프로세서들은 각각이 독립된 주소 공간에서 실행된다.(일반적으로 메모리 공유 못하게함)
  - 대게는 소켓이나 메일박스, 메시지 큐와 같이 운영체제에서 제공하는 통신 기능을 이용하여 서로 통신한다.
  - 로컬 프로세스를 최상위 컴포넌트라 생각한다면, 컴포넌트간 의존성을 동적 다형성을 통해 관리하는 저수준 컴포넌트로 구성 (배포 단위)
  - 로컬 프로세스에서 고수준 프로세스의 소스 코드가 저수준 프로세스의 이름, 물리 주소, 레지스트리 조회 키를 절대로 포함하면 안된다.
    - 아키텍처 관점의 목표에서 저수준 프로세스가 고수준 프로세스의 플러그인이 되도록 만들자
  - 로컬 프로세스간 통신은 운영체제 호출, 데이터 마샬링 및 언마샬링, 프로세스 간 문맥 교환등이 있으며 이들은 제법 비싼 작업이다.
    - 빈번하게 이뤄지지 않도록 신중하게 제한
    
- 서비스
  - 물리적인 형태를 띠는 가장 강력한 경계는 서비스이다.
  - 서로 통신하는 두 서비스는 물리적으로 동일한 프로세서나 멀티코어에서 동작할 수 있고, 아닐 수도 있다.
    - 서비스들은 모든 통신이 네트워크를 통해 이뤄진다.
  - 서비스 경계를 지나는 통신은 함수 호출에 비해 매우 느리기 때문에 빈번하게 통신하는 일을 피해야 한다.
    - 지연에 따른 문제를 고수준에서 처리할 수 있어야 한다.
  - 로컬 서비스와 동일하게 저수준 서비스는 반드시 고수준 서비스에 '플러그인'되어야 한다.
  
- 결론
  - 단일체를 제외한 대다수 시스템은 한 가지 이상의 경계 전략을 사용한다.
  - 서비스 > 로컬 프로세스 > 소스 코드 컴포넌트 단일체 또는 배포형 컴포넌트의 집합
  
  
  
# 참고
- https://wikidocs.net/495
