# 18장 경계 해부학
- 서론
  - 시스템 아키텍처는 일련의 소프트웨어 컴포넌트와 그 컴포넌트들을 분리하는 경계에 의해 정의된다.
  
- 경계 횡단하기
  - 적절한 위치에서 경계를 횡단하게 하는 비결은 소스 코드 의존성 관리에 있다.
    - 소스 코드 모듈 하나가 변경되면, 이에 의존하는 다른 소스 코드 모듈도 변경하거나, 다시 컴파일해서 새로 배포해야 할지도 모른다.
  - 경계는 이러한 변경이 전파되는 것을 막는 방화벽을 구축하고 관리하는 수단으로써 존재
  
- 두려운 단일체(모노리틱)
  - 소스 수준 분리 모드
    - 함수와 데이터가 단일 프로세서에서 같은 주소 공간을 공유하며 나름의 규칙에 따라 분리
  - 배포 관점에서는 단일 실행 파일에 지나지 않는다. (링크, jar, EXE)
    - 단일 실행 파일을 만들더라고 그 안에 포함된 다양한 컴포넌트를 개발하고 바이너리로 만드는 과정을 독립적으로 수행할 수 있게 하는 것은 대단히 가치 있는 일이다.
  - 단일체 아키텍처는 대부분 동적 다형성에 의존하여 내부 의존성을 관리한다.
    - 동적 다형성이 없었더라면 함수 포인터를 사용해야 했고 위험하기 때문에 컴포넌트를 분리하려는 시도도 결국 포기했을 것이다.
  - 가장 단순한 형태의 경계 횡단은 저수준 클라이언트에서 고수준 서비스로 향하는 함수 호출
    - 런타임과 컴파일 의존성 방향이 같다. 
    - 그림 18.1)
  - 고수준 클라이언트가 저수준 서비스를 호출해야 한다면 동적 다형성을 사용하여 제어 흐름과는 반대로 방향으로 의존성 역전시킬 수 있다.
    - 런타임 의존성과 컴파일 의존성은 반대가 된다.
    - 그림 18.2) 
  - 정적 링크된 모노리틱 구조의 실행 파일도 이처럼 규칙적인 방식으로 구조를 분리하면 프로젝트 개발, 테스트, 배포하는 작업에 큰 도움이 된다.
    - 독립성이 유지된다.
  - 단일체의 컴포넌트간 통신은 매우 빠르고 값싸다.
  - 단일체의 배포는 소스 코드 형태로 전달된다.

- 배포형 컴포넌트
  - 아키텍처의 경계가 물리적으로 드러날 수도 있는데 그중 가장 단순한 형태는 동적 링크 라이브러리
    - ex) .NET DLL, 자바 jar, 루비 젬 등 (별도 컴파일 하지 않고 바로 사용 가능)
  - 배포 작업은 단순히 이들 배포 가능한 단위를 좀 더 편리한 형태로 묶는 역할
    - ex) WAR
  - 이러한 배포 과정에서만 차이가 날 뿐, 배포 수준의 컴포넌트는 단일체와 동일한다.
    - 하지만 정적 다형성을 사용할 수 없다. (컴파일시 이미 결정나기 때문에)
  - 단일체와 동일하게 컴포넌트간 통신은 매우 값싸다.
  
- 스레드
  - 스레드는 아키텍처 경계도 아니며 배포 단위도 아니다.
  - 스레드는 실행 계획과 순서를 체계화하는 방벙에 가깝다.
  
- 로컬 프로세스
  - 훨씬 강한 물리적 형태를 띠는 아키텍처 경계로 로컬 프로세스가 있다.
  - 로컬 프로세서들은 각각이 독립된 주소 공간에서 실행된다.(일반적으로 메모리 공유 못하게함)
  - 대게는 소켓이나 메일박스, 메시지 큐와 같이 운영체제에서 제공하는 통신 기능을 이용하여 서로 통신한다.
  - 로컬 프로세스를 최상위 컴포넌트라 생각한다면, 컴포넌트간 의존성을 동적 다형성을 통해 관리하는 저수준 컴포넌트로 구성 (배포 단위)
  - 로컬 프로세스에서 고수준 프로세스의 소스 코드가 저수준 프로세스의 이름, 물리 주소, 레지스트리 조회 키를 절대로 포함하면 안된다.
    - 아키텍처 관점의 목표에서 저수준 프로세스가 고수준 프로세스의 플러그인이 되도록 만들자
  - 로컬 프로세스간 통신은 운영체제 호출, 데이터 마샬링 및 언마샬링, 프로세스 간 문맥 교환등이 있으며 이들은 제법 비싼 작업이다.
    - 빈번하게 이뤄지지 않도록 신중하게 제한
    
- 서비스
  - 물리적인 형태를 띠는 가장 강력한 경계는 서비스이다.
  - 서로 통신하는 두 서비스는 물리적으로 동일한 프로세서나 멀티코어에서 동작할 수 있고, 아닐 수도 있다.
    - 서비스들은 모든 통신이 네트워크를 통해 이뤄진다.
  - 서비스 경계를 지나는 통신은 함수 호출에 비해 매우 느리기 때문에 빈번하게 통신하는 일을 피해야 한다.
    - 지연에 따른 문제를 고수준에서 처리할 수 있어야 한다.
  - 로컬 서비스와 동일하게 저수준 서비스는 반드시 고수준 서비스에 '플러그인'되어야 한다.
  
- 결론
  - 단일체를 제외한 대다수 시스템은 한 가지 이상의 경계 전략을 사용한다.
  - 서비스 > 로컬 프로세스 > 소스 코드 컴포넌트 단일체 또는 배포형 컴포넌트의 집합
  
# 19장 정책과 수준
- 서론
  - 소프트웨어 시스템이란 정책을 기술한 것이다.
  - 컴퓨터 프로그램은 각 입력을 출력으로 변환하는 정책을 상세하게 기술한 설명서
  - 대다수 주요 시스템에서 하나의 정책은 이 정책을 서술하는 여러 개의 조그만 정책들로 쪼갤 수 있다.
  - 소프트웨어 아키텍처를 개발하는 기술에는 이러한 정책을 신중하게 분리하고, 정책이 변경되는 양상에 따라 정책을 재편성하는 일도 포함
    - 동일한 이유로 동일한 시점에 변경되는 정책은 동일 컴포넌트
    - 서로 다른 이유, 혹은 다른 시점에 변경되는 정책은 다른 컴포넌트로
  - 흔히 아키텍처 개발은 재편성된 컴포넌트들을 비순환 방향 그래프로 구성하는 기술을 포함한다.
    - 정점은 동일한 수준의 정책을 포함하는 컴포넌트에 해당, 방향이 있는 간선은 컴포넌트 사이의 의존성을 나타낸다. (간선은 다른 수준에 위치한 컴포넌트 서로 연결)
    - 저수준 컴포넌트가 고수준 컴포넌트에 의존하도록 설계되어야 한다.
    
- 수준
  - 수준은 엄밀하게 정의하자면 '입력과 출력까지의 거리'다.
    - 시스템의 입력과 출력 모두로부터 멀리 위치할수록 정책의 수준은 높아진다. (고수준)
    - 입력과 출력의 정책은 최하위 수준 (저수준)
    
  - 그림 19.1
    - 번역 컴포넌트는 입력과 출력에서 가장 멀리 떨어져 있기 때문에 최고 수준 컴포넌트
    - 데이터 흐름과 소스 코드 의존성이 항상 같은 방향은 아니다.
      - 소스 코드 의존성은 그 수준에 따라 결합되어야 하지, 데이터 흐름을 기준으로 결합되면 안 된다.
  - 그림 19.2
    - 고수준이 저수준을 참조 하고 있는 부분을 인터페이스를 통해서 분리해서 개선 했음
        
  - 단일 책임 원칙(SRP)과 공통 폐쇄 원칙(CCP)에 따르면 동일한 이유로 동일한 시점에 변경되는 정책은 함께 묶인다.
    - 고수준 정책은 저수준 정책에 비해 덜 빈번하게 변경되고, 보다 중요한 이유로 변경된다.
    - 저수준 정책은 더 빈번하게 변경되며, 보다 긴급성을 요하며, 덜 중요한 이유로 변경된다.

- 결론
  - 이장에서 정책에 대한 논의는 단일 책임 원칙, 개방 폐쇄 원칙, 공통 폐쇄 원칙, 의존성 역전 원칙, 안정된 의존성 원칙, 안정된 추상화 원칙을 모두 포함
  
# 20장 업무 규칙
- 서론
  - 애플리케이션을 업무 규칙(고수주)과 플러그인(저수준)으로 구분하려면 업무 규칙을 실제로 잘 이해해야만 한다.
  - 업무 규칙은 사업적으로 수익을 얻거나 비용을 줄일 수 있는 규칙 또는 절차다. (컴퓨터 구현 여부와 상관 없이)
    - 핵심 업무 규칙이란 컴퓨터로 구현을 하든, 직원이 수동으로 하든 상관 없이 사업 자체에 핵심적
    - 핵심 업무 규칙은 보통 데이터를 요구한다.
      - 이러한 데이터를 핵심 업무 데이터라 부른다.
  - 핵심 규칙과 핵심 데이터는 본질적으로 결합되어 있기 떄문에 객체로 만들 좋은 후보가 되고, 이러한 유형의 객체를 엔티티라 하겠다.
  
- 엔티티
  - 엔티티는 컴퓨터 시스템 내부의 객체로서, 핵심 업무 데이터를 기반으로 동작하는 일련의 조그만 핵심 업무 규칙을 구체화한다.
  - 엔티티의 인터페이스는 핵심 업무 데이터를 기반으로 동작하는 핵심 업무 규칙을 구현한 함수들로 구성된다.
  - 그림 20.1
    - 핵심 업무 데이터를 포함하며, 데이터와 관련된 세 가지 핵심 업무 규칙을 인터페이스로 제공
  - 엔티티 클래스는 데이터베이스, 사용자 인터페이스, 서드파티 프레임워크에 대한 고려사항들로 인해 오염되어서는 절대 안된다.
    - 엔티티는 순전히 업무에 대한 것이며, 이외의 것은 없다.
  - 엔티티의 유일한 요구조건은 핵심 업무 데이터와 핵심 업무 규칙을 하나로 묶어서 별도의 소프트웨어 모듈로 만들어야 한다는 것이다.
  
- 유스케이스
  - 모든 업무 규칙이 엔티티처럼 순수한 것은 아니다.
    - 자동화된 시스템이 동작하는 방법을 정의하고 제약함으로써 수익을 얻거나 비용을 줄이는 업무 규칙도 존재 (수동 환경 사용 못함)
  - 유스케이스는 자동화된 시스템이 사용되는 방법을 설명한다.
  - 엔티티 내의 핵심 업무 규칙과는 반대로, 유스케이스는 애플리케이션에 특화된 업무 규칙을 설명한다.
  - 유스케이스는 엔티티 내부의 핵심 업무 규칙을 어떻게, 그리고 언제 호출할지를 명시하는 규칙을 담는다. (엔티티를 제어)
    - 예) 그림 20.2 에서 Customer가 엔티티에 대한 참조이며, 은행과 고객의 관계를 결정짓는 핵심 업무 규칙은 Customer 엔티티에 포함된다.
  - 유스케이스는 사용자 인터페이스를 기술하지 않는다.
    - 웹인지, 리치 클라이언트인지, 콘솔 기반인지, 순수한 서비스인지를 구분하기 불가능
  - 애플리케이션에 특화된 규칙을 설명하며, 이를 통해 사용자와 엔티티 사이의 상호작용을 규정한다.
    - 시스템에서 데이터가 들어오고 나가는 방식은 유스케이스와 무관하다.
  - 엔티티(고수준)는 자신을 제어하는 유스케이스(저수준)에 대해 아무것도 알지 못한다.
    - 유스케이스는 단일 애플리케이션에 특화되어 있으며 해당 시스템의 입력과 출력에 보다 가깝게 위치하게 때문이다.
    - 엔티티는 수많은 다양한 애플리케이션에서(웹, 앱 구분 없이) 사용될 수 있도록 일반화된 것이므로, 각 시스템의 입력이나 출력에서 더 멀리 떨어져 있다.
    
- 요청 및 응답 모델
  - 제대로 구성된 유스케이스 객체라면 데이터를 사용자나 또 다른 컴포넌트와 주고 받는 방식에 대해서 전혀 눈치챌 수 없어야 한다.
  - 유스케이스는 단순한 요청 데이터 구조를 입력으로 받아들이고, 단순한 응답 데이터 구조를 출력으로 반환한다.
  - 요청 및 응답 모델이 독립적이지 않다면, 그 모델에 의존하는 유스케이스도 결국 해당 모델이 수반하는 의존성에 간접적으로 결합된다.
  - 엔티티 객체를 가리키는 참조를 요청 및 응답 데이터 구조에 포함하지 마라 (목적이 완전히 다름)
    - 포함하면 결국 코드에 수많은 떠돌이 데이터가 만들어지고, 수많은 조건문이 추가된다.
    
- 결론
  - 업무 규칙은 사용자 인터페이스나 데이터베이스와 같은 저수준의 관심사로 인해 오염되어서는 안 되며, 원래 그대로의 모습으로 남아 있어야 한다.
  - 업무 규칙은 시스템에서 가장 독립적이며 가장 많이 재사용할 수 있는 코드여야 한다.
  
# 21장 소리치는 아키텍처
- 서론
  - 상위 수준의 디렉터리 구조, 최상위 패키지에 담긴 소스 파일을 볼때, 프레임워크나 도구가 아닌 유스케이스를 중심으로 두라는 얘기 인듯
  
- 아키텍처의 테마
  - 야콥슨의 책을 설명하며 소프트웨어 아키텍처는 시스템의 유스케이스를 지원하는 구조라고 지적했다.
  - 아키텍처는 프레임워크에 대한 것이 아니다.(절대 그래서도 안된다.)
  - 아키텍처를 프레임워크 중심으로 만들어 버리면 유스케이스가 중심이 되는 아키텍처는 절대 나올 수 없다.
  
- 아키텍처의 목적
  - 좋은 아키텍처는 유스케이스를 중심에 두기 떄문에, 프레임워크나 도구, 환경에 전혀 구애받지 않고 유스케이스를 지원하는 구조를 아무런 문제 없이 기술할 수 있다.
  - 좋은 소프트웨어 아키텍처는 프레임워크, 데이터베이스, 웹 서버, 그리고 여타 개발 환경 문제나 도구에 대해서는 결정을 미룰 수 있도록 만든다.
  - 좋은 아키텍처는 유스케이스에 중점을 두며, 지엽적인 관심사에 대한 결합은 분리시킨다.

- 하지만 웹은?
  - 웹은 전달 메커니즘(입출력 장치)이며, 애플리케이션 아키텍처에서도 그와 같이 다뤄야 한다.
  - 시스템 아키텍처는 시스템이 어떻게 전달될지에 대해 가능하다면 아무것도 몰라야 한다.

- 프레임워크는 도구일 뿐, 삶의 방식은 아니다.
  - '프레임워크가 모든 것을 하게 하자' 라는 태도는 우리가 취하고 싶은 태도가 아니다.
  - 프레임워크가 아키텍처의 중심을 차지하는 일을 막을 수 있는 전략을 개발하라.

- 테스트하기 쉬운 아키텍처
  - 아키텍처가 유스케이스를 최우선으로 하고, 프레임워크와는 적당한 거리를 둔다면, 프레임워크를 전혀 준비하지 않더라도 필요한 유스케이스 전부에 대해 단위 테스트를 할 수 있어야 한다.
  - 엔티티 객체는 반드시 오래된 방식의 간단한 객체여야 하며, 프레임워크나 데이터베이스, 또는 여타 복잡한 것들에 의존해서는 안 된다.
  - 유스케이스 객체가 엔티티 객체를 조작해야 한다.

- 결론
  - 아키텍처는 시스템을 이야기해야 하며, 시스템에 적용한 프레임워크에 대해 이야기해서는 안 된다.

  

# 참고
- https://wikidocs.net/495
