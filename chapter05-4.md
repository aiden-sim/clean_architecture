# 26장 메인(Main) 컴포넌트
### 서론
- 메인(main) 컴포넌트 : 나머지 컴포넌트를 생성하고, 조정하며, 관리하는 컴포넌트

### 궁극적인 세부사항
- 메인 컴포넌트는 가장 낮은 수준의 정책
- 메인은 모든 팩토리(Factory)와 전략(Strategy), 그리고 시스템 전반을 담당하는 나머지 기반 설비를 생성한 후, 시스템에서 더 높은 수준을 담당하는 부분으로 제어권을 넘기는 역할
- 메인을 통해서 의존성 주입이 이뤄져야 하고, 주입되고 나면 의존성 주입 프레임워크 없이 의존성을 분배할 수 있다.
- 가장 지저분한 컴포넌트

- 예제
  - 간단한 입력 명령어 해석 등은 main 함수에서 처리하지만, 명령어를 실제로 처리하는 일은 다른 **고수준 컴포넌트** 로 위임
  - 메인은 클린 아키텍처에서 가장 바깥 원에 위치하는, 지저분한 저수준 모듈
  - 메인은 고수준의 시스템을 위한 모든 것을 로드한 후, 제어권을 고수준의 시스템에게 넘긴다.
  
### 결론
- 초기 조건과 설정을 구성하고, 외부 자원을 모두 수집한 후, 제어권을 애플리케이션의 고수준 정책으로 넘기는 플러그인
- 메인을 여러개 둘 수 있음
  - ex) 개발용, 테스트용, 상용
  
# 27장 '크고 작은 모든' 서비스들
### 서론
- SOA와 MSA가 인기를 끌고 있는 이유
  - 서비스를 사용하면 상호 결합이 철저하게 분리되는 것처럼 보인다. (일부만 맞는말)
  - 서비스를 사용하면 개발과 배포 독립성을 지원하는 것처럼 보인다. (일부만 맞는말)
  
### 서비스 아키텍처?
- 서비스를 사용한다고 해서 아키텍처에 해당하는것은 아님
- 시스템 아키텍처는 의존성 규칙을 준수하며 고수준의 정책을 저수준의 세부사항으로부터 분리하는 경계에 의해 정의
  - 반면 서비스는 애플리케이션의 행위를 분리할 뿐인 서비스라면 값비싼 함수 호출에 불과
- 모든 서비스가 반드시 아키텍처 관점을 따라야 되는건 아니지만 기능을 독립적으로 서비스를 생성하면 의존성 규칙 준수 여부와 상관없이 큰 도움이 됨
- 함수들의 구성 형태도 비슷한데 모노리틱이나 컴포넌트 기반 시스템에서 아키텍처를 정의하는 요소는 의존성 규칙을 따르며 아키텍처 경계를 넘나드는 함수 호출들이다.
  - 반면 나머지 많은 함수들은 행위를 서로 분리할 뿐 (아키텍처적으로 중요하지 않음)
- 결론 : 서비스든 함수든 분리한다고 해서 다 아키텍처가 아니라 아키텍처 규칙과 경계를 지켜야 아키텍처 관점으로 중요하다.

### 서비스의 이점?
- 서비스를 까기 시작함

#### 결합 분리의 오류
- 서비스의 큰 이점은 서비스 사이의 결합이 확실히 분리됨
  - 반론
    - 하지만 프로세스 내의 또는 네트워크 상의 공유 자원 때문에 결합될 가능성이 여전히 존재
    - 서로 공유하는 데이터에 의해 이들 서비스는 강력하게 결합
    - 서비스 사이를 오가는 데이터 레코드에 새로운 필드가 추가된다면? 관련 서비스들 다 변경해 줘야 된다.
- 인터페이스가 잘 정의되어 있어야 한다.
  - 반론
    - 함수의 경우도 다르지 않다. 서비스라고 함수 인터페이스보다 더 잘 정의되는 것은 아니다.

#### 개발 및 배포 독립성의 오류
- 데브옵스 전략으로 전담팀에서 각 서비스를 작성, 유지보수, 운영을 책임질 수 있다. 이러한 개발 및 배포 독립성은 확장 가능한 것으로 간주된다.
  - 반론
    - 엔터프라이즈 시스템은 서비스 기반 외에도 모노리틱, 컴포넌트 기반 시스템으로도 구축할 수 있다.
    - 서비스라고 해서 항상 독립적으로 개발, 배포, 운영할 수 있는것은 아니다. (데이터나 행위에 결합되어 있다면 결합된 정도에 맞게 조정해야됨)
    
### 야옹이 문제
- 확장 가능 시스템을 구축하기 위해 수많은 작은 마이크로 서비스 기반으로 구축하기로 결정했고 개발팀을 소규모팀으로 세분화했음 
- ![example1](https://user-images.githubusercontent.com/7076334/100074476-236e7600-2e82-11eb-99b4-d239ad721b8f.png)

  - TaxiUI : 고객을 담당, 모바일 기기를 이용해 택시 호출
  - TaxiFinder : 여러 TaxiSupplier 현황을 검토, 사용자에게 적합한 택시 후보군 선별
  - TaxiSelector : 타겟팅에 맞춰서 적합한 택시를 선택
  - TaxiDispatcher : TaxiSelector가 선택한 택시에 배차 지시
- 야옹이 배달하는 서비스를 런칭하고 싶다. (마케팅 부서 요구)
  - 여러 요구 요청사항과 제약사항들
- 야옹이 배달 기능을 추가하려면 개발과 배포 전략을 신중하게 조정해야 한다.
  - 이 서비스에 모두 결합되어 있어서 독립적으로 개발하고, 배포하거나, 유지될 수 없다.
- 바로 횡단 관심사가 지닌 문제다.
  - 기능적 분해는 새로운 기능이 기능적 행위를 횡단하는 상황에서 매우 취약하다.
  
### 객체가 구출하다.
- 컴포넌트 기반 아키텍처에서는 SOLID 설계 원칙을 들여다보면, 다형적 확장할 수 있는 클래스 집합을 생성해 새로운 기능을 처리
- ![example2](https://user-images.githubusercontent.com/7076334/100078296-bad5c800-2e86-11eb-8c81-6c8a92b1a259.png)

  - 야옹이 문제 그림과 비슷하지만 경계를 주목하자. 또한 의존성들이 의존성 규칙을 준수하고 있다.
  - 원래 서비스의 로직 중 대다수가 이 객체 모델의 기반 클래스들 내부로 녹아듬
    - 하지만 배차 특화된 로직은 부분은 Rides 컴포넌트로 추출되고, 야옹이에 대한 신규 기능은 Kittens 컴포넌트에 들어감
    - Rides나 Kittens 컴포넌트는 기존 컴포는트들에 있는 추상 기반 클래스를 템플릿 메서드나 전략 패턴 등을 이용하여 오버라이드 (의존성 규칙을 준수)
  - 이 전략을 따르더라도 야옹이 기능을 추가하면 TaxiUI는 변경해야 된다. 하지만 나머지는 변경할 필요가 없다.
  
### 컴포넌트 기반 서비스
- 서비스도 이렇게 할 수 있을까?
  - 서비스는 SOLID 원칙대로 설계할 수 있으며 컴포넌트 구조를 갖출 수도 있다.
  - 이를 통해서 서비스 내의 기존 컴포넌트들을 변경하지 않고도 새로운 컴포는트 추가 가능
- 서비스를 하나 이상의 jar 파일에 포함되는 추상 클래스들의 집합이라 생각한다.
  - 새로 jar 파일을 구성하는 클래스들은 기존 jar 파일에 정의된 추상 클래스들을 확장해서 만든다.
  - 서비스 로드 경로에 새로운 jar 파일을 추가하면 된다.
  - 즉 **새로운 기능을 추가하는 행위가 개방 폐쇄 원칙을 준수한다.**

- ![example3](https://user-images.githubusercontent.com/7076334/100083215-7a794880-2e8c-11eb-8466-057f13e7158b.png)
  - 서비스 존재는 같지만, 각 서비스의 내부는 자신만의 컴포넌트 설계로 되어 있어서 파생 클래스를 만드는 방식으로 신규 기능 추가 가능
    - 파생 클래스들은 각자의 컴포넌트 내부에 놓인다.
    
### 횡단 관심사
- 아키텍처 경계가 서비스 사이에 있지 않다.
- 모든 주요 시스템
- ![example4](https://user-images.githubusercontent.com/7076334/100084108-afd26600-2e8d-11eb-83ae-17917c5ecb1e.png)
  - 서비스 내부는 의존성 규칙도 준수하는 컴포넌트 아키텍처로 설계해야 한다.
  - 서비스들은 시스템 아키텍처 경계를 정의하지 않고, 아키텍처 경계를 정의하는 것은 서비스 내에 위치한 컴포넌트다.
  
### 결론
- 서비스는 시스템의 확장성과 개발 가능성 측면에서 유용하지만, 그 자체로는 아키텍처적으로 그리 중요한 요소는 아니다.
- 시스템 아키텍처는 시스템 내부에 그어진 경계와 경계를 넘나드는 의존성에 의해 정의된다.

# 28장 테스트 경계
- 테스트는 시스템의 일부이며, 아키텍처에도 관여한다.

### 시스템 컴포넌트인 테스트
- 아키텍처 관점에서는 모든 테스트가 동일하다.
- 테스트는 태생적으로 의존성 규칙을 따른다.
  - 테스트는 세부적이며 구체적인 것으로 의존성은 항상 테스트 대상이 되는 코드를 향한다.
  - 시스템 내부의 어떤 것도 테스트에 의존하지 않는다.
- 테스트는 독립적인 배포 가능하다.
  - 테스트 시스템에만 배포하고, 사용 시스템에는 배포하지 않는다.
- 테스트는 시스템 컴포넌트 중에서 가장 고립되어 있다.
  - 테스트 역할은 운영이 아닌 개발 지원 (그렇다고 컴포넌트가 아니라는 뜻은 아님)
  - 테스트는 다른 모든 시스템 컴포넌트가 반드시 지켜야 하는 모델을 표현해준다. 

### 테스트를 고려한 설계
- 테스트는 배포하지 않는 다는 사실과, 테스트가 시스템의 설계 범위 밖에 있다고 여기는데 잘못된 관점이다.
- 테스트가 시스템의 설계와 잘 통합되지 않으면, 테스트는 깨지기 쉽고 시스템은 변경하기 어려워진다.
- 시스템이 변경되면 테스트가 깨지기 쉽다.
- 깨지기 쉬운 테스트는 시스템을 뻣뻣하게 만든다. (부작용)
- 이러한 문제를 해결하려면 테스트를 고려해서 설계해야 된다.
- 소프트웨어 설계의 첫번째 규칙은 언제나 같다. **변동성이 있는 것에 의존하지 마라**
  - 업무 규칙을 테스트할 수 있게 해야 한다.

### 테스트 API
- 이 API는 사용자 인터페이스가 사용하는 인터랙터(Interactor)와 인터페이스(Interface Adaptor) 어댑터들의 상위 집합이 될 것이다.
- 테스트 API는 테스트를 애플리케이션으로부터 분리할 목적으로 사용한다. (애플리케이션 구조로부터 결합을 분리)

#### 구조적 결합
- 구조적 결합은 테스트 결합 중에서 가장 강하며, 가장 은밀하게 퍼져 나가는 유형이다.
  - 모든 클래스와 모든 메서드에 대해 존재하는 테스트 스위트는 애플리케이션 구조에 강하게 결합
- 테스트 API의 역할은 애플리케이션의 구조를 테스트로부터 숨기는데 있다.
  - 이러면 상용 코드를 리팩토링 하거나 진화 시키더라도 테스트에 영향을 주지 않는다.
  - 테스트를 리팩터링하거나 진화시킬 때도 사용 코드에 전혀 영향을 주지 않는다.
- 따로 따로 진화는 테스트 코드는 계속 더 구체적이고 특화된 형태로 변하고, 상용 코드는 추상적이고 범용적인 형태로 변할 것이다.

#### 보안
- 테스트 API를 운영에 배포하면 위험할 수도 있는데 이를 피하고 싶다면 위험한 부분의 구현부는 독립적으로 배포할 수 있는 컴포넌트로 분리해야 한다.

### 결론
- 테스트에서 기대하는 안정성과 회귀의 이점을 얻을 수 있으려면 테스트는 잘 설계 돼야만 한다.
- 테스트를 시스템의 일부로 설계하지 않으면 테스트는 깨지기 쉽고 유지보수하기 어려워지는 경향이 있다.
    
 
  


