# 5부 아키텍처
# 15장 아키텍처란?
- 서 론
  - 소프트웨어 아키텍트
    - 최고의 프로그래머이며, 계속 프로그래밍 작업을 맡을뿐 아니라 동시에 생산성을 극대화할 수 있는 설계를 하도록 방향을 이끈다.
    - 프로그래밍 작업을 계속하는 이유는, 문제를 경험하지 않는다면 다른 프로그래머를 지원하는 작업을 제대로 수행할 수 없기 때문이다.

  - 소프트웨어 시스템의 아키텍처란 시스템을 구축했던 사람들이 만들어낸 시스템의 형태다.
    - 그 형태는 아키텍처 안에 담긴 소프트웨어 시스템이 쉽게 개발, 배포, 운영, 유지보수되도록 만들어진다.

  - 소프트웨어 아키텍처의 목표가 시스템을 제대로 동작하도록 만드는데 있다고 생각할 수 있지만, 이는 관련이 없다.
  - 아키텍처의 주된 목적은 시스템의 생명주기를 지원하는 것이다.
    - 아키텍처의 궁극적인 목표는 시스템의 수명과 관련된 비용은 최소화하고, 프로그래머의 생산성은 최대화하는데 있다.

- 개 발
  - 개발하기 힘든 시스템이라면 수명이 길지도 않고 건강하지도 않을 것이다.
    - 아키텍처는 개발팀이 시스템을 쉽게 개발할 수 있도록 뒷받침해야 한다.
  - 팀 구조가 다르면 아키텍처 관련 결정에서도 차이가 난다.
    - 팀이 적다면 잘 정의된 컴포넌트나 인터페이스가 없더라도 효율적으로 협력하여 모놀리틱 시스템을 개발할 수 있다.
      - 초기에 아키텍처 관련 제약들이 오히려 방해가 된다고 여길 수도 있다.
    - 팀이 분리되어 있다면 시스템을 신뢰할 수 있고 안정된 인터페이스를 갖춘, 잘 설계된 컴포넌트 단위로 분리해야 한다.
      - **팀별 단일 컴포넌트** 가 최적이진 않지만 일정에만 쫒겨 일한다면, 결국 이 아키텍처로 귀착될 것이다.
  
- 배 포
  - 배포 비용이 높을수록 시스템의 유용성은 떨어진다.
    - 아키텍처는 시스템을 단 한번에 쉽게 배포할 수 있도록 해야 한다.
  - 마이크로 서비스의 예
    - 너무 많은 마이크로서비스는 서로 연결하기 위해 설정하고 작동 순서를 결정하는 과정에서 오작동이 발생될 수 있다.
    
- 운 영
  - 아키텍처는 개발, 배포, 유지보수에 미치는 영향보다 운영에 미치는 영향이 더 적다.
    - 적다는 것이지 시스템을 쉽게 운영하게 해주는 아키텍처가 바람직하지 않다는 것은 아니다.
  - 하드웨어는 값 싸고 인력은 비싸다.
    - 운영을 방해하는 아키텍처가 개발, 배포, 유지보수를 방해하는 아키텍처보다 비용이 덜 든다.
  - 좋은 소프트웨어 아키텍처는 시스템을 운영하는데 필요한 요구도 알려준다.
    - 유스케이스, 기능, 시스템의 필수 행위를 일급 엔티티로 격상 시키고, 개발자들에게 주요 목표로 인식되도록 한다.
      - => 시스템 이해도가 높아지며, 따라서 개발과 유지보수에 큰 도움이 된다.

- 유지보수
  - 소프트웨어 시스템에서 비용이 가장 많이 든다.
  - 유지보수의 가장 큰 비용은 탐사와 이로 인한 위험부담에 있다.
    - 탐사란 기존 소프트웨어에 기능을 추가하거나 수정 시, 어디를 고치는 것이 최선인지 그리고 어떤 전략을 쓰는게 최적일지 결정하는 비용. 
    - 변경사항을 반영 시, 결함에 대한 위험 부담도 추가된다.
  - 주의를 기울여 신중하게 아키텍처를 만들면 이 비용을 크게 줄일 수 있다.
  
- 선택사항 열어 두기
  - 소프트웨어는 행위적 가치와 구조적 가치를 지닌다. (소프트웨어를 부드럽게 만들기 때문이 구조적 가치가 더 중요)
    - 2장) 행위는 기능개발하고, 버그 수정하고 / 구조는 아키텍처 (행위를 빠르고 쉽게 변경할 수 있도록)
  - 소프트웨어를 부드럽게 유지하는 방법은 선택사항을 가능한 많이, 그리고 가능한 오랫동안 열어 두는 것이다.
    - 여기서 말하는 열어둬야할 선택사항은 바로 **중요치 않은 세부사항** 이다.
  - 모든 소프트웨어 시스템은 **정책**과 **세부사항**으로 분해할 수 있다.
    - 정책이란 시스템의 진정한 가치가 살아 있는 곳 (정책 요소는 모든 업무 규칙과 업무 절차를 구체화한다.)
    - 세부사항은 사람, 외부 시스템, 프로그래머가 정책과 소통할 때 필요한 요소 (정책이 가진 행위는 영향을 미치지 않음)
      - ex) 입출력 장치, 데이터베이스, 웹 시스템, 서버, 프레임워크, 통신 프로토콜 등
  - 아키텍트의 목표는 시스템에서 정책을 가장 핵심적인 요소로 식별하고, 동시에 세부사항은 정책에 무관하게 만들 수 있는 형태의 시스템을 구축
    - 개발 초기에 데이터베이스 시스템 선택할 필요가 없음
    - 개발 초기에 웹 서버를 선택할 필요가 없음
    - 개발 초기에 REST를 적용할 필요가 없음
    - 개발 초기에 의존성 주입 프레임워크를 적용할 필요가 없음
      - 결론 : 세부사항에 몰두하지 않은 채 고수준의 정책을 만들 수 있다면, 이러한 세부사항에 대한 결정을 연기할 수 있다.
  - 선택사항을 더 오랫동안 열어 둘 수 있다면 더 많은 실험을 해볼 수 있고 더 많은 것을 시도할 수 있다.
  - **좋은 아키텍트는 결정되지 않은 사항의 수를 최대화한다.**
    
- 장치 독립성
  - 저자가 잘못한 수많은 실수사례
    - 코드를 입출력 장치와 직접 결합한 사례 (장치 종속적)
      - 카드 판독기에서 카드를 읽어야 할 경우 카드 판독기와 직접 상호작용하도록 코드 작성 / 천공 카드에 구멍을 뚫어야 할 경우에도 카드 천공기를 직접 조작하는 코드 작성
        - 큰 규모의 천공카드 뭉치는 관리하기 어렵고 잃어 버리거나 찢어지거나 등 여러가지 문제 대두
      - 자기 테이프를 이용해서 문제 해결할 수 있지만 프로그램을 다시 작성해야 되서 너무 큰 작업
    - 결국 추상화를 통해 장치 독립성 생각해냄 (개방 폐쇄 원칙의 탄생 순간)
  
- 광고 우편
  - 정책을 세부사항으로 부터 분리했던 사례 (광고 우편)
    - 라인 프린터 (비쌈) => 자기 테이프를 사용해서 오프라인 프린터 다섯대랑 연결
      - 정책은 이름과 주소 레코드에 대한 서식
      - 세부사항은 장치 (라인 프린터 대신 자기 테이프)
        
- 물리적 주소 할당
  - 고수준의 정책이 디스크의 물리적 구조로부터 독립되도록 수정한 사례
  
- 결 론
  - 좋은 아키텍트는 세부사항을 정책으로부터 신중하게 가려내고, 정책이 세부사항과 결합되지 않도록 엄격하게 분리
  - 좋은 아키텍트는 세부사항에 대한 결정을 가능한 오랫동안 미룰 수 있는 방향으로 정책 설계
  
# 16장 독립성
- 서 론
  - 좋은 아키텍처는 다음을 지원해야 한다.
    - 시스템의 유스케이스
    - 시스템의 운영
    - 시스템의 개발
    - 시스템의 배포
    
- 유스케이스
  - 시스템의 아키텍처는 시스템의 의도를 지원해야 한다.
    - ex) 장바구니 애플리케이션이라면 장바구니 관련 유스케이스를 지원해야 한다.
  - 아키텍처는 반드시 유스케이스를 지원해야 한다. (최우선)
  - 아키텍처는 시스템의 행위에 큰 영향을 주지 않는다.
    - 하지만 좋은 아키텍처가 행위를 지원하기 위해 할 수 있는 일 중 가장 중요한 사항은 행위를 명확히 하고 위부로 드러내며, 이를 통해 시스템이 지닌 의도를 아키텍처 수준에서 알아 볼 수 있게 만드는 것

- 운 영
  - 시스템의 운영 지원 관점에서 볼 때 아키텍처는 더 실질적이며 덜 피상적인 역할을 맡는다.
  - 뛰어난 아키텍트라면 여러가지 경우를 열어 둔다.
    - 시스템의 처리 요소를 일련의 작은 서비스들로 배열하여, 서로 다른 서버에서 병렬로 실행 하는 시스템
    - 경량의 수 많은 스레드가 단일 프로세스에서 같은 주소 공간을 공유하도록 처리하는 시스템
    - 독립된 주소 공간에서 실행되는 소수의 프로세스만으로 충분한 시스템
    - 단일 프로세스에서 실행되는 단순한 모놀리틱 프로그램 정도의 시스템
    
- 개 발
  - 아키텍처는 개발환경을 지원하는데 있어 핵심적인 역할을 수행한다.
  - 콘 웨이 법칙
    - 시스템을 설계하는 조직이라면 어디든지 그 조직의 의사소통 구조와 동일한 구조의 설계를 만들어 낼 것이다.

- 배 포
  - 아키텍처는 배포 용이성을 결정하는데 중요한 역할을 한다.
    - 목표는 즉각적인 배포다.
  - 좋은 아키텍처라면 시스템이 빌드된 후 즉각 배포할 수 있도록 지원해야 한다.
    - 이런 아키텍처를 만들려면 시스템을 컴포넌트 단위로 적절하게 분할하고 격리시켜야 한다.
    
- 선택사항 열어 놓기
  - 좋은 아키텍처는 컴포넌트 구조와 관련된 관심사들 사이에서 균형을 맞추고, 각 관심사 모두를 만족시킨다.
    - 하지만 현실에서는 이러한 균형을 잡기가 매우 어렵다.
      - 모든 유스케이스를 알 수 없다.
      - 운영하는데 따르는 제약사항, 팀 구조, 배포 요구사항도 알지 못한다.
      - 이러한 사항들을 알고 있더라도, 시스템이 생명주기의 단계를 하나씩 거쳐감에 따라 이 사항들도 반드시 변해간다.
  - 좋은 아키텍처는 선택사항을 열어 둠으로써, 향후 시스템에 변경이 필요할 때 어떤 방향으로든 쉽게 변경할 수 있도록 한다.
 
- 계층 결합 분리
  - 아키텍트는 유스케이스 전부를 알지는 못하지만 시스템의 기본적인 의도는 분명히 알고 있다.
  - 아키텍트는 단일 책임 원칙과 공통 폐쇄 원칙을 적용하여, 그 의도의 맥락에 따라서 다른 이유로 변경되는 것들을 분리하고, 동일한 이유로 변경되는 것들은 묶는다.
  - 서로 다른 이유로 변경되는 이유는?
    - 업무 규칙과는 관련 없음
    - 유스케이스가 두 가지 요소를 모두 포함한다면 뛰어난 아키텍트는 UI 부분과 업무 규칙 부분을 서로 분리하고자 할 것이다. (독립적으로 변경)
  - 업무 규칙은 그 자체가 애플리케이션과 밀접한 관련이 있거나, 혹은 더 범용적일 수도 있다.
    - ex) 애플리케이션 자체 업무 규칙과 업무 도메인에 더 밀접하게 연관된 업무 규칙
      - 이 둘은 다른 속도로로 다른 이유로 변경될 것이기 때문에 서로 분리하고 독립적으로 변경할 수 있도록 만들어야 됨
  - 데이터베이스, 쿼리 언어, 스키마 조차 세부사항이며, 업무 규칙이나 UI와는 관련 없다. (독립적으로 변경)
  - 수평적 계층으로 분리 하는 방법
    - ex) UI, 애플리케이션에 특화된 업무, 애플리케이션과 독립적인 업무, 데이터베이스 등
  
- 유스케이스 결합 분리
  - 유스케이스 자체도 서로 다른 이유로 변경된다.
  - 유스케이스는 시스템을 분할하는 매우 자연스러운 방법이다.
    - ex) 주문 추가, 주문 삭제
  - 유스케이스는 시스템의 수평적인 계층을 가로지르도록 자른, 수직으로 좁다란 조각이기도 하다.
    - ex) 161P 그림
      - AOP 개념과 비슷 (회당 관심사)
  
- 결합 분리 모드
  - 
