# 3부 설계원칙
- 좋은 벽돌(패러다임?)로 좋은 아키텍처를 정의하는 원칙이 필요한데, 그게 바로 SOLID다.
- SOLID 원칙의 목적은 중간 수준(모듈 수준)의 소프트웨어 구조가 다음과 같도록 만드는데 있다.
  - 변경에 유연하다.
  - 이해하기 쉽다.
  - 많은 소프트웨어 시스템에 사용될 수 있는 컴포넌트의 기반이 된다.
- SOLID의 개략적인 원칙
  - SRP(단일 책임 원칙) : 소프트우ㅐ어 모듈은 변경의 이유가 하나, 단 하나여야만 한다.
  - OCP(개방-폐쇄 원칙) : 기존 코드를 수정하기보다는 반드시 새로운 코드를 추가하는 방식으로 시스템의 행위를 변경할 수 있도록 설계해야만 소프트웨어 시스템을 쉽게 변경할 수 있다.
  - LSP(리스코프 치환 원칙) : 상호 대체 가능한 구성요소를 이용해 소프트웨어를 만들 수 있으려면, 이들 구성요소는 반드시 서로 치환 가능해야 한다.
  - ISP(인터페이스 분리 원칙) : 소프트웨어 설계자는 사용하지 않은 것에 의존하지 않아야 한다.
  - DIP(의존성 역전 원칙) : 고수준 정책을 구현하는 코드는 저수준 세부사항을 구현하는 코드에 절대로 의존해서는 안된다. 대신 세부사항이 정책에 의존해야 한다.
    - 이 책에서는 설명이 아니라 이들 원칙이 아키텍처 관점에서 지닌 의미에 집중해 논의한다.

# 7장) SRP: 단일 책임 원칙
- 모든 모듈이 단 하나의 일만 해야 한다는 의미로 받아들이기 쉽다.
- 1. 역사적으로 SRP는 아래와 같이 기술되어 왔다.
  - **단일 모듈은 변경의 이유가 하나, 오직 하나뿐이어야 한다.**
- 2. 책에서 말한 SRP는 소프트웨어 시스템은 사용자와 이해관계자를 만족시키기 위해 변경된다.
  - 하나의 모듈은 하나의, 오직 하나의 사용자 또는 이해관계자에 대해서만 책임져야 한다.
- 3. SRP의 최종 버전
  - 하나의 모듈은 하나의, 오직 하나의 액터(해당 변경을 요청하는 한 명 이상의 사람들) 에 대해서만 책인져야 한다.

- '모듈'이란 무슨 뜻인가?
  - 단순한 정의는 소스 파일
  - 코드를 소스 파일에 저장하지 않는다면 이런 경우 모듈은 단순히 함수와 데이터 구조로 구성된 응집된 집합
  - 결론 : '응집된' 이라는 단어가 SRP를 암시하고, 단일 액터를 책임지는 코드를 함께 묶어주는 힘이 바로 응집성이다.
  
- **징후 1:우발적 중복**
  - P.67 Employee 예제
    - 이 클래스는 SRP를 위반하는데, 이들 세 가지 메서드가 서로 다른 세명의 액터를 책임지고 있다.
      - calculatePay() 메서드는 회계팀에서 기능을 정의하며, CFO 보고를 위해 사용
      - reportHours() 메서드는 인사팀에서 기능을 정의하고 사용하며, COO 보고를 위해 사용
      - save() 메서드는 데이터베이스 관리자(DBA)가 기능을 정의하고, CTO 보고를 위해 사용
    - 결론 : 위 예제의 문제는 서로 다른 액터가 의존하는 코드를 너무 가까이 배치했기 때문이다. SRP는 서로 다른 액터가 의존하는 코드를 서로 분리하라고 말한다.
    
- **징후 2:병합**
  - 소스 파일에 다양하고 많은 메서드를 포함하면 병합이 자주 발생할 수 있다. (특히 서로 다른 액터를 책임진다면 병합이 발샌할 가능성이 더 높다.)
    - ex) 서로 다른 팀 개발자가 Employee 클래스를 체크아웃받아 변경사항을 적용하다가 병합발생
    - 최근 도구는 굉장히 뛰어나지만 결국 병합에는 항상 위험이 뒤따르게 된다.
  - 결론 : 이 문제를 벗어나는 방법은 서로 다른 액터를 뒷받침하는 코드를 서로 분리하는 것이다.
  
- **해결책**
  - 메서드를 각기 다른 클래스로 이동 시킨다.
  - 가장 확실한 해결책은 데이터와 메서드를 분리하는 방식
    - 1. 그림 7.3) 데이터 구조인 EmployeeData 클래스를 만들어, 세 개의 클래스가 공유.
      - 각 클래스는 자신의 메서드에 반드시 필요한 소스 코드만 포함. 세 클래스는 서로의 존재를 몰라야 한다. (우연한 중복 회피)
      - 단점 : 개발자가 세 가지 클래스를 인스턴스화 하고 추적해야 한다. (퍼사드 패턴을 사용해서 해결)
    - 2. 그림 7.4) 퍼사드(Facade) 패턴을 이용
      - EmployeeFacade는 세 클래스의 객체를 생성하고, 요청된 메서드를 가지는 객체로 위임하는 일을 책임진다.
    - 3. 그림 7.5) 가장 중요한 메서드는 기존의 Employee 클래스에 그대로유지하되, Employee 클래스를 덜 중요한 나머지 메서드들에 대한 퍼사드로 사용
      - 모든 클래스는 반드시 단 하나의 메서드를 가져야 하나는 주장에 근거하여 앞의 해결책에 반대할 수도 있다.
      - 하지만 여러 메서드가 하나의 가족을 이루고, 메서드의 가족을 포함하는 각 클래스는 하나의 유혀범위가 된다. (햇갈림...)
  
- 결론
  - 단일 책임 원칙은 메서드와 클래스 수준의 원칙이다.
  - 하지만 상위의 두 수준에서도 다른 형태로 다시 등장한다.
    - 컴포넌트 수준에서는 공통 폐쇄 원칙(Common Closure Principle)
    - 아키텍처 수준에서는 아키텍처 경계(Architectural Boundary)의 생성을 책임지는 변경의 축이 된다.

# 8장) OCP: 개방-폐쇄 원칙
- 



# 9장) LSP: 리스코프 치환 원칙
- 



# 10장) ISP: 이터페이스 분리 원칙
- 



# 11장) DIP: 의존성 역전 원칙
- 
  
  
# 참고)
- 모듈과 컴포넌트) https://imcreator.tistory.com/7
