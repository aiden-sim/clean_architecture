# 2부 소개
- 패러다임이란 프로그래밍을 하는 방법으로, 대체로 언어에는 독립적이다.
- 패러다임은 어떤 프로그래밍 구조를 사용할지, 그리고 언제 이 구조를사용해야 하는지를 결정한다.

# 3장) 패러다임 개요
- 이 장에서는 세 가지 패러다임인 구조적 프로그래밍, 객체지향 프로그래밍, 함수형 프로그래밍에 대해 설명한다.

- 구조적 프로그래밍
  - 구조적 프로그래밍은 제어흐름의 직접적인 전환에 대해 규칙을 부과한다.

- 객체 지향 프로그래밍
  - 객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 대해 규칙을 부과한다.


- 함수형 프로그래밍
  - 세 패러다임 중 가장 먼저 만들어졌다.
  - 함수형 프로그래밍은 할당문에 대해 규칙을 부과한다.

- 생각할 거리
  - 각 패러다임은 프로그래머에게 권한을 박탈할 뿐, 어느 패러다임도 새로운 권한을 부여하지 않는다.
  - 각 패러다임은 부정적인 의도를 가지는 일종의 추가적인 규칙을 부과한다. (무엇을 해서는 안되는지...)
  
- 결론
  - 세 가지 패러다임과 아키텍처의 세 가지 큰 관심사가(함수, 컴퓨넌트 분리, 데이터 관리)가 어떻게 서로 연관되는지에 주목하자.


# 4장) 구조적 프로그래밍
- 서론
  - 구조적 프로그래밍을 발견 한, 데이크스트라에 대한 설명 (원시적인 환경에서도 위대한 발견을 해냈다.)
  
- 증명
  - 프로그램들의 어려운 조건들을 데이크스트라는 증명(proof)이라는 수학적인 언리를 적용하여 이 문제를 해결하고자 했다.
  - goto 문장이 모듈을 더 작은 단위로 재귀적으로 분해하는 과정에 방해가 되는 경우가 있다는 사실을 발견 (증명 기법인 분할 정복 접근법 사용 못함)
    - if/then/else와 do/while 같은 분기와 반복이라는 단순한 제어 구조를 사용하면 문제가 되지 않는다는 것을 발견
      - 이러한 구조는 순차 실행과 결합했을 때 특별하다는 사실을 깨달았다. (데이스트라)
  - 모든 프로그래미을 순차, 분기, 반복 이라는 세 가지 구조만으로 표현할 수 있다. (뵘과 야코피니)
    - 구조적 프로그래밍의 탄생
  - 순차 구문
    - 단순한 열거법을 이용
    - 각 순차 구문의 입력을 순차 구문의 출력까지 수학적으로 추적한다. (일반적 수학적 증명 방식과 같다.)
  - 분기
    - 열거법을 재적용
    - 분기를 통한 각 경로를 열거
  - 반복
    - 귀납법을 사용 (관찰과 경험을 통해 자료를 수집하고, 수집한 자료에서 비롯된 성향, 관련성을 가지고 결론 도출)
    
- 해로운 성명서
  - 현재의 우리 모두는 구조적 프로그래머이며, 여기에는 선태의 여지가 없다.
    - 제어흐름을 제약 없이 직접 전환할 수 있는 선택권 자체를 언어에서 미제공
  
- 기능적 분해
  - 구조적 프로그래밍으로 인해 거대한 문제 기술서를 받더라도 문제를 고수준의 기능들로 분해할 수 있다. 
  - 그리고 이들 각 기능은 다시 저수준의 함수들로 분해할 수 있고, 이러한 분해 과정을 끝없이 반복할 수 있다.
  - 이렇게 분해한 기능들은 구조적 프로그래밍의 제한된 제어 구조를 이용하여 표현할 수 있다.
  - 구조적 분석/구조적 설계 (유행)
    - 대규모 시스템을 모듈과 컴포넌트로 나눌 수 있고, 더 나아가 모듈과 컴포넌트는 입증할 수 있는 아주 작은 기능들로 세분화 가능
    
- 엄밀한 증명은 없었다.
  - 프로그램 관점에서 정리에 대한 유클리드 계층구조는 끝내 만들어지지 않았다.
  - 상당히 성공한 또 다른 전략으로는 과학적 방법이 있다.
  
- 과학이 구출하다.
  - 과학적 방법은 반증은 가능하지만 증명은 불가능하다.
  - 수학은 증명 가능한 서술이 참임을 입증하는 원리라고 볼 수 있다. 반면 과학은 증명 가능한 서술이 거짓임을 입증하는 원리라고 볼 수 있다.
  
- 테스트
  - "테스트는 버그가 있음을 보여줄 뿐, 버그가 없음을 보여줄 수는 없다."
    - 오히려 소프트웨어는 수학적인 시도가 아니라 과학과 같다.
      - 테스트를 통해 증명 가능한 세부 기능들이 거짓인지를 증명하려고 시도한다.(테스트가 실패한다면 참이라고 여긴다.)
    
- 결론
  - 소프트웨어 
  
  
  
