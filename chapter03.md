# 3부 설계원칙
- 좋은 벽돌(패러다임?)로 좋은 아키텍처를 정의하는 원칙이 필요한데, 그게 바로 SOLID다.
- SOLID 원칙의 목적은 중간 수준(모듈 수준)의 소프트웨어 구조가 다음과 같도록 만드는데 있다.
  - 변경에 유연하다.
  - 이해하기 쉽다.
  - 많은 소프트웨어 시스템에 사용될 수 있는 컴포넌트의 기반이 된다.
- SOLID의 개략적인 원칙
  - SRP(단일 책임 원칙) : 소프트 모듈은 변경의 이유가 하나, 단 하나여야만 한다.
  - OCP(개방-폐쇄 원칙) : 기존 코드를 수정하기보다는 반드시 새로운 코드를 추가하는 방식으로 시스템의 행위를 변경할 수 있도록 설계해야만 소프트웨어 시스템을 쉽게 변경할 수 있다.
  - LSP(리스코프 치환 원칙) : 상호 대체 가능한 구성요소를 이용해 소프트웨어를 만들 수 있으려면, 이들 구성요소는 반드시 서로 치환 가능해야 한다.
  - ISP(인터페이스 분리 원칙) : 소프트웨어 설계자는 사용하지 않은 것에 의존하지 않아야 한다.
  - DIP(의존성 역전 원칙) : 고수준 정책을 구현하는 코드는 저수준 세부사항을 구현하는 코드에 절대로 의존해서는 안된다. 대신 세부사항이 정책에 의존해야 한다.
    - 이 책에서는 설명이 아니라 이들 원칙이 아키텍처 관점에서 지닌 의미에 집중해 논의한다.

# 7장) SRP: 단일 책임 원칙
- 서론
  - 모든 모듈이 단 하나의 일만 해야 한다는 의미로 받아들이기 쉽다.
  - 1. 역사적으로 SRP는 아래와 같이 기술되어 왔다.
    - **단일 모듈은 변경의 이유가 하나, 오직 하나뿐이어야 한다.**
  - 2. 책에서 말한 SRP는 소프트웨어 시스템은 사용자와 이해관계자를 만족시키기 위해 변경된다.
    - 하나의 모듈은 하나의, 오직 하나의 사용자 또는 이해관계자에 대해서만 책임져야 한다.
  - 3. SRP의 최종 버전
    - 하나의 모듈은 하나의, 오직 하나의 액터(해당 변경을 요청하는 한 명 이상의 사람들) 에 대해서만 책인져야 한다.

  - '모듈'이란 무슨 뜻인가?
    - 단순한 정의는 소스 파일
    - 코드를 소스 파일에 저장하지 않는다면 이런 경우 모듈은 단순히 함수와 데이터 구조로 구성된 응집된 집합
    - 결론 : '응집된' 이라는 단어가 SRP를 암시하고, 단일 액터를 책임지는 코드를 함께 묶어주는 힘이 바로 응집성이다.
  
- **징후 1:우발적 중복**
  - P.67 Employee 예제
    - 이 클래스는 SRP를 위반하는데, 이들 세 가지 메서드가 서로 다른 세명의 액터를 책임지고 있다.
      - calculatePay() 메서드는 회계팀에서 기능을 정의하며, CFO 보고를 위해 사용
      - reportHours() 메서드는 인사팀에서 기능을 정의하고 사용하며, COO 보고를 위해 사용
      - save() 메서드는 데이터베이스 관리자(DBA)가 기능을 정의하고, CTO 보고를 위해 사용
    - 결론 : 위 예제의 문제는 서로 다른 액터가 의존하는 코드를 너무 가까이 배치했기 때문이다. SRP는 서로 다른 액터가 의존하는 코드를 서로 분리하라고 말한다.
    
- **징후 2:병합**
  - 소스 파일에 다양하고 많은 메서드를 포함하면 병합이 자주 발생할 수 있다. (특히 서로 다른 액터를 책임진다면 병합이 발샌할 가능성이 더 높다.)
    - ex) 서로 다른 팀 개발자가 Employee 클래스를 체크아웃받아 변경사항을 적용하다가 병합발생
    - 최근 도구는 굉장히 뛰어나지만 결국 병합에는 항상 위험이 뒤따르게 된다.
  - 결론 : 이 문제를 벗어나는 방법은 서로 다른 액터를 뒷받침하는 코드를 서로 분리하는 것이다.
  
- **해결책**
  - 메서드를 각기 다른 클래스로 이동 시킨다.
  - 가장 확실한 해결책은 데이터와 메서드를 분리하는 방식
    - 1. 그림 7.3) 데이터 구조인 EmployeeData 클래스를 만들어, 세 개의 클래스가 공유.
      - 각 클래스는 자신의 메서드에 반드시 필요한 소스 코드만 포함. 세 클래스는 서로의 존재를 몰라야 한다. (우연한 중복 회피)
      - 단점 : 개발자가 세 가지 클래스를 인스턴스화 하고 추적해야 한다. (퍼사드 패턴을 사용해서 해결)
    - 2. 그림 7.4) 퍼사드(Facade) 패턴을 이용
      - EmployeeFacade는 세 클래스의 객체를 생성하고, 요청된 메서드를 가지는 객체로 위임하는 일을 책임진다.
    - 3. 그림 7.5) 가장 중요한 메서드는 기존의 Employee 클래스에 그대로유지하되, Employee 클래스를 덜 중요한 나머지 메서드들에 대한 퍼사드로 사용
      - 모든 클래스는 반드시 단 하나의 메서드를 가져야 하나는 주장에 근거하여 앞의 해결책에 반대할 수도 있다.
      - 하지만 여러 메서드가 하나의 가족을 이루고, 메서드의 가족을 포함하는 각 클래스는 하나의 유범위가 된다. (햇갈림...)
  
- 결론
  - 단일 책임 원칙은 메서드와 클래스 수준의 원칙이다.
  - 하지만 상위의 두 수준에서도 다른 형태로 다시 등장한다.
    - 컴포넌트 수준에서는 공통 폐쇄 원칙(Common Closure Principle)
    - 아키텍처 수준에서는 아키텍처 경계(Architectural Boundary)의 생성을 책임지는 변경의 축이 된다.

# 8장) OCP: 개방-폐쇄 원칙
- 서론
  - 소프트웨어 개체는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.
    - 즉 소프트웨어 개체의 행위는 확장할 수 있어야 하지만, 이때 개체를 변경해서는 안 된다.
  - 아키텍처 컴포넌트 수주에서 OCP를 고려할 때 훨씬 중요한 의미를 가진다.

- **사고 실헝**
  - 요구 사항이 들어 왔을때 변경을 최소하 하려면?
    - 서로 다른 목적으로 변경되는 요소를 적절하게 분리하고(SRP), 이들 요소 사이의 의존성을 체계화함으로써(DIP) 변경량을 최소화할 수 있다.
  - P.75 SRP를 적용
    - 보고서 생성이 두 개의 책임으로 분리된다.
      - 1) 보고서용 데이터를 계산하는 책임
      - 2) 이 데이터를 웹으로 보여주거나 종이로 프린트하기에 적합한 형태로 표현하는 책임
    - 이처럼 책임을 분리했다면, 두 책임 중 하나에서 변경이 발생해도 다른 하나는 변경되지 않도록 소스 코드 의존성을 확실히 조직화해야 한다.
    - 또한, 새로 조직화한 구조에서는 행위가 확장될 때 변경이 발생하지 않음을 보장해야 한다.
      - 이러한 목적을 달성하려면 처리 과정을 클래스 단위로 분할하고, 이들 클래스를 컴포넌트 단위로 구분해야 한다. (그림 8.2)
        - 여기서 주목할 점은 모든 의존성이 소스 코드 의존성을 나타낸다는 사실이다. (순환참조 X)
        - 이중선은 화살표와 오직 한 방향으로만 교차한다. (모든 컴포넌트 관계는 단방향으로 이루어짐)
    - 예제에서 Interactor는 OCP를 가장 잘 준수할 수 있는 곳에 위치한다. (다른 컴포넌트 변경에 영향 없음)
      - Interactor는 업무 규칙을 포함하기 때문에 애플리케이션에서 가장 높은 수준의 정책을 포함한다.
      - Interactor > Controller > Presenter > View (고수준 <- 저수준)
  - 아키텍트는 기능이 어떻게(how), 왜(why), 언제(when) 발생하는지에 따라서 기능을 분리하고, 분리한 기능을 컴포넌트의 계층구조로 조직화한다.
    - 이렇게 조직화하면 저수준 컴포넌트에서 발생한 변경으로부터 곳준 컴포넌트를 보호할 수 있다.

- **방향성 제어**
  - 그림 8.2 예제에서 FinancialDataGateway 인터페이스가 없었다면, 의존성이 Interactor -> Database 컴포넌트로 바로 향하게 된다. (고수준 -> 저수준)
    - 이렇게 되면 결합도가 강하지게 된다.
    
- **정보 은닉**
  - 그림 8.2의 FinancialReportRequester 인터페이스는 방향성 제어와 다른 목적을 가진다.(은닉성)
    - 이 인터피에스가 없다면 Controller는 FinancialEntities에 대해서 추이 종속성을 가지게 된다.
      - 추이 종속성 : A -> B -> C 에 의존하게 된다면 A -> C에 의존하게 된다. 만약 클래스 의존성이 순환적이라면 순환참조 문제가 생김
  
- 결론
  - OCP의 목표는 시스템을 확장하기 쉬운 동시에 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록 하는데 있다.
  - 이러한 목표를 달성하려면 시스템을 컴포넌트 단위로 분리하고, 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있는 형태의 의존성 계층구조가 만들어지도록 한다.

# 9장) LSP: 리스코프 치환 원칙
- 서론
  - S 타입의 객체 o1 각각에 대응하는 T 타입 객체 o2가 있고, T 타입을 이용해서 정의한 모든 프로그램 P에서 o2의 자리에 o1을 치환하더라도 P의 행위가 변하지 않는다면, S는 T의 하위 타입니다.
  
- **상속을 사용하도록 가이드하기**
  - 그림 9.1 설계는 LSP를 준수하는데, Billing 애플리케이션의 행위가 License 하위 타입 중 무엇을 사용하는지에 전혀 의존하지 않기 때문이다.
  - 이들 하위 타입은 모두 License 타입을 치환할 수 있다.
  
- **정사각형/직사각형 문제**
  - 그림 9.2 예제에서 Rectangle(직사각형)의 높이와 너비는 서로 독립적으로 변경될 수 있는 반면, Square(정사각형)의 높이와 너비는 반드시 함께 변경된다.
  - if문 등을 이용해 Rectangle이 실제로 Square 인지 검사하는 메커니즘을 추가하면 User의 행위가 사용하는 타입에 의존하게 되므로, 결국 타입을 서로 치환할 수 없게 된다.

- **LSP와 아키텍처**
  - 초창기에는 LSP는 상속을 사용하도록 가이드하는 방법 정도로 간주되었다.
  - 시간이 지나면서 LSP는 인터페이스와 구현체에도 적용되는 더 광범위한 소프트에어 설계 원칙으로 변모해 왔다.
  - 아키텍처 관점에서 LSP를 이해하는 최선의 방법은 이 원칙을 어겼을 때 시스템 아키텍처에서 무슨 일이 일어나는지 관찰하는 것이다.
  
- **LSP 위배 사례**
  - 택시 업체 예제
    - 서비스 사양서를 지키지 않으면 예외 로직이 발생한다.
    - 위 예제에서는 URI를 키로 분리해서 설정 정보를 만들었다.
  
- 결론
  - LSP는 아키텍처 수준까지 확장할 수 있고, 반드시 확장해야만 한다.
  - 치환 가능성을 조금이라도 위배하면 시스템 아키텍처가 오염되어 상당량의 별도 메커니즘을 추가해야 할 수 있기 때문이다.


# 10장) ISP: 터페이스 분리 원칙
- 서론
  - 그림 10.1 처럼 OPS가 정적 타입 언어로 작성된 클래스인 경우 User1에서는 op2, op3을 사용하지 않아도 User1 소스코드는 이 두 메서드에 의존하게 된다.
  - 이런 의존성 떄문에 연관 없는 코드가 변경되도 User1도 다시 컴파일한 후 새로 배포해야 한다.
  - 이러한 문제는 인터페이스 단위로 분리하여 해결할 수 있다.
  
- **ISP와 언어**
  - 정적 타입 언어는 사용자가 import 같은 include와 같은 타입 선언문을 사용하도록 강제 하는데, 소스 코드에 included 선언문으로 인해 소스 코드 의존성이 발생하고, 이로 인해 재컴파일 또는 재배포가 강제되는 상황이 무조건 초래된다.
  - 동적 타입 언어는 소스 코드에 이러한 선언문이 존재하지 않는다. 대신 런타임에 추론이 발생한다.
    - 소스 코드 의존성이 아예 없으며, 결국 재컴파일과 재배포가 필요없다.
  - 동적 타입 언어를 사용하면 정적 타입 언어를 사용할 때보다 유연하며 결합도가 낮은 시스템을 만들 수 있다.
  
- **ISP와 아키텍처**
  - 일반적으로, 필요 이상으로 많은 걸 포함하는 모듈에 의존하는 것은 해로운 일이다.
  - 소스 코드 의존성의 경우 이는 분명한 사실인데, 불필요한 재컴파일과 재배포를 강제하기 떄문이다.
  
- 결론
  - 불필요한 짐을 실은 무언가에 의존하면 예상치도 못한 문제에 빠진다는 사실이다.



# 11장) DIP: 의존성 역전 원칙
- 서론
  - 의존성 역전 원칙에서 말하는 '유연성이 극대화된 시스템'이란 소스 코드 의존성이 추상에 의존하며 구체에는 의존하지 않는 시스템이다.
  - DIP를 논의할 때 운영체제나 플랫폼 같이 안정성이 보장된 환경에 대해서는 무시하는 편이다.
  - 우리가 의존하지 않도록 피하고자 하는 것이 바로 변동성이 큰 구체적인 요소다. (자주 변경될 수밖에 없는 모듈)
  
- **안정된 추상화**
  - 인터페이스는 구현체보다 변동성이 낮다.
  - 안정된 소프트웨어 아키텍처란 변동성이 큰 구현체에 의존하는 일은 지양하고, 안정된 추상 인터페이스를 선호하는 아키텍처라는 뜻
    - 변동성이 큰 구체 클래스를 참조하지 말라
    - 변동성이 큰 구체 클래스로부터 파생하지 말라
      - 상속은 아주 신중하게 사용해야 한다.
    - 구체 함수를 오버라이드 하지 말라.
      - 구체 함수를 오버라이드 하면 그 의존성까지 상속하게 된다.
    - 구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 말라.
    
    
- **팩토리**
  - 자바 등 대다수의 객체 지향 언어에서 이처럼 바람직하지 못한 의존성을 처리할 때 추상 팩토리를 사용하곤 한다.
  - 그림 11.1의 곡선은 아키텍처 경계를 뜻한다.
    - 곡선은 시스템을 두 가지 컴포넌트로 분리한한다.
    - 하나는 추상 컴포넌트이며, 다른 하나는 구체 컴포넌트다.
  - 제어흐름은 소스 코드 의존성과는 정반대 방향으로 곡선을 가로지른다.
    - 소스 코드 의존성은 제어흐름과는 반대 방향으로 역전된다.
    
- **구체 컴포넌트**
  - DIP 위배를 모두 없앨 수는 없다. 하지만 DIP를 위배하는 클래스들은 적은 수의 구체 컴포넌트 내부로 모을 수 있고, 이를 통해 시스템의 나머지 부분과 분리할 수 있다.

- 결론
  - 그림 11.1의 곡선은 이후 아키텍처의 경계가 될 것이다. 그리고 의존성은 이 곡선을 경계로, 더 추상적인 엔티티가 있는 쪽으로만 향한다.
  
  
  
  
  
  
  
  
# 참고)
- 모듈과 컴포넌트) https://imcreator.tistory.com/7
